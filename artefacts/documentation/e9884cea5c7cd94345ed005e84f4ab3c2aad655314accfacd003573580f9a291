
     * Open the camera, blocking it until it succeeds or fails.
     *
     * <p>Note that the Handler provided must not be null. Furthermore, if there is a handler,
     * its Looper must not be the current thread's Looper. Otherwise we'd never receive
     * the callbacks from the CameraDevice since this function would prevent them from being
     * processed.</p>
     *
     * <p>Throws {@link CameraAccessException} for the same reason {@link CameraManager#openCamera}
     * does.</p>
     *
     * <p>Throws {@link BlockingOpenException} when the open fails asynchronously (due to
     * {@link CameraDevice.StateCallback#onDisconnected(CameraDevice)} or
     * ({@link CameraDevice.StateCallback#onError(CameraDevice)}.</p>
     *
     * <p>Throws {@link TimeoutRuntimeException} if opening times out. This is usually
     * highly unrecoverable, and all future calls to opening that camera will fail since the
     * service will think it's busy. This class will do its best to clean up eventually.</p>
     *
     * @param cameraId
     *            Id of the camera
     * @param listener
     *            Listener to the camera. onOpened, onDisconnected, onError need not be implemented.
     * @param handler
     *            Handler which to run the listener on. Must not be null.
     *
     * @return CameraDevice
     *
     * @throws IllegalArgumentException
     *            If the handler is null, or if the handler's looper is current.
     * @throws CameraAccessException
     *            If open fails immediately.
     * @throws BlockingOpenException
     *            If open fails after blocking for some amount of time.
     * @throws TimeoutRuntimeException
     *            If opening times out. Typically unrecoverable.
     