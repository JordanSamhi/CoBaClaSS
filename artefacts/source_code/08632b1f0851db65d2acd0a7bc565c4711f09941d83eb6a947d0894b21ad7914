public int getOffsetForHorizontal(int line, float horiz, boolean primary){
    final int lineEndOffset = getLineEnd(line);
    final int lineStartOffset = getLineStart(line);
    Directions dirs = getLineDirections(line);
    TextLine tl = TextLine.obtain();
    tl.set(mPaint, mText, lineStartOffset, lineEndOffset, getParagraphDirection(line), dirs, false, null, getEllipsisStart(line), getEllipsisStart(line) + getEllipsisCount(line));
    final HorizontalMeasurementProvider horizontal = new HorizontalMeasurementProvider(line, primary);
    final int max;
    if (line == getLineCount() - 1) {
        max = lineEndOffset;
    } else {
        max = tl.getOffsetToLeftRightOf(lineEndOffset - lineStartOffset, !isRtlCharAt(lineEndOffset - 1)) + lineStartOffset;
    }
    int best = lineStartOffset;
    float bestdist = Math.abs(horizontal.get(lineStartOffset) - horiz);
    for (int i = 0; i < dirs.mDirections.length; i += 2) {
        int here = lineStartOffset + dirs.mDirections[i];
        int there = here + (dirs.mDirections[i + 1] & RUN_LENGTH_MASK);
        boolean isRtl = (dirs.mDirections[i + 1] & RUN_RTL_FLAG) != 0;
        int swap = isRtl ? -1 : 1;
        if (there > max)
            there = max;
        int high = there - 1 + 1, low = here + 1 - 1, guess;
        while (high - low > 1) {
            guess = (high + low) / 2;
            int adguess = getOffsetAtStartOf(guess);
            if (horizontal.get(adguess) * swap >= horiz * swap) {
                high = guess;
            } else {
                low = guess;
            }
        }
        if (low < here + 1)
            low = here + 1;
        if (low < there) {
            int aft = tl.getOffsetToLeftRightOf(low - lineStartOffset, isRtl) + lineStartOffset;
            low = tl.getOffsetToLeftRightOf(aft - lineStartOffset, !isRtl) + lineStartOffset;
            if (low >= here && low < there) {
                float dist = Math.abs(horizontal.get(low) - horiz);
                if (aft < there) {
                    float other = Math.abs(horizontal.get(aft) - horiz);
                    if (other < dist) {
                        dist = other;
                        low = aft;
                    }
                }
                if (dist < bestdist) {
                    bestdist = dist;
                    best = low;
                }
            }
        }
        float dist = Math.abs(horizontal.get(here) - horiz);
        if (dist < bestdist) {
            bestdist = dist;
            best = here;
        }
    }
    float dist = Math.abs(horizontal.get(max) - horiz);
    if (dist <= bestdist) {
        best = max;
    }
    TextLine.recycle(tl);
    return best;
}