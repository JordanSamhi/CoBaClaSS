public boolean showSaveLocked(){
    if (mDestroyed) {
        Slog.w(TAG, "Call to Session#showSaveLocked() rejected - session: " + id + " destroyed");
        return false;
    }
    final FillResponse response = getLastResponseLocked("showSaveLocked(%s)");
    final SaveInfo saveInfo = response == null ? null : response.getSaveInfo();
    if (saveInfo == null) {
        if (sVerbose)
            Slog.v(TAG, "showSaveLocked(" + this.id + "): no saveInfo from service");
        return true;
    }
    if ((saveInfo.getFlags() & SaveInfo.FLAG_DELAY_SAVE) != 0) {
        if (sDebug)
            Slog.v(TAG, "showSaveLocked(" + this.id + "): service asked to delay save");
        return false;
    }
    final ArrayMap<AutofillId, InternalSanitizer> sanitizers = createSanitizers(saveInfo);
    final ArrayMap<AutofillId, AutofillValue> currentValues = new ArrayMap<>();
    final ArraySet<AutofillId> savableIds = new ArraySet<>();
    final AutofillId[] requiredIds = saveInfo.getRequiredIds();
    boolean allRequiredAreNotEmpty = true;
    boolean atLeastOneChanged = false;
    boolean isUpdate = false;
    if (requiredIds != null) {
        for (int i = 0; i < requiredIds.length; i++) {
            final AutofillId id = requiredIds[i];
            if (id == null) {
                Slog.w(TAG, "null autofill id on " + Arrays.toString(requiredIds));
                continue;
            }
            savableIds.add(id);
            final ViewState viewState = mViewStates.get(id);
            if (viewState == null) {
                Slog.w(TAG, "showSaveLocked(): no ViewState for required " + id);
                allRequiredAreNotEmpty = false;
                break;
            }
            AutofillValue value = viewState.getCurrentValue();
            if (value == null || value.isEmpty()) {
                final AutofillValue initialValue = getValueFromContextsLocked(id);
                if (initialValue != null) {
                    if (sDebug) {
                        Slog.d(TAG, "Value of required field " + id + " didn't change; " + "using initial value (" + initialValue + ") instead");
                    }
                    value = initialValue;
                } else {
                    if (sDebug) {
                        Slog.d(TAG, "empty value for required " + id);
                    }
                    allRequiredAreNotEmpty = false;
                    break;
                }
            }
            value = getSanitizedValue(sanitizers, id, value);
            if (value == null) {
                if (sDebug) {
                    Slog.d(TAG, "value of required field " + id + " failed sanitization");
                }
                allRequiredAreNotEmpty = false;
                break;
            }
            viewState.setSanitizedValue(value);
            currentValues.put(id, value);
            final AutofillValue filledValue = viewState.getAutofilledValue();
            if (!value.equals(filledValue)) {
                boolean changed = true;
                if (filledValue == null) {
                    final AutofillValue initialValue = getValueFromContextsLocked(id);
                    if (initialValue != null && initialValue.equals(value)) {
                        if (sDebug) {
                            Slog.d(TAG, "id " + id + " is part of dataset but initial value " + "didn't change: " + value);
                        }
                        changed = false;
                    }
                } else {
                    isUpdate = true;
                }
                if (changed) {
                    if (sDebug) {
                        Slog.d(TAG, "found a change on required " + id + ": " + filledValue + " => " + value);
                    }
                    atLeastOneChanged = true;
                }
            }
        }
    }
    final AutofillId[] optionalIds = saveInfo.getOptionalIds();
    if (sVerbose) {
        Slog.v(TAG, "allRequiredAreNotEmpty: " + allRequiredAreNotEmpty + " hasOptional: " + (optionalIds != null));
    }
    if (allRequiredAreNotEmpty) {
        if (optionalIds != null && (!atLeastOneChanged || !isUpdate)) {
            for (int i = 0; i < optionalIds.length; i++) {
                final AutofillId id = optionalIds[i];
                savableIds.add(id);
                final ViewState viewState = mViewStates.get(id);
                if (viewState == null) {
                    Slog.w(TAG, "no ViewState for optional " + id);
                    continue;
                }
                if ((viewState.getState() & ViewState.STATE_CHANGED) != 0) {
                    final AutofillValue currentValue = viewState.getCurrentValue();
                    final AutofillValue value = getSanitizedValue(sanitizers, id, currentValue);
                    if (value == null) {
                        if (sDebug) {
                            Slog.d(TAG, "value of opt. field " + id + " failed sanitization");
                        }
                        continue;
                    }
                    currentValues.put(id, value);
                    final AutofillValue filledValue = viewState.getAutofilledValue();
                    if (value != null && !value.equals(filledValue)) {
                        if (sDebug) {
                            Slog.d(TAG, "found a change on optional " + id + ": " + filledValue + " => " + value);
                        }
                        if (filledValue != null) {
                            isUpdate = true;
                        }
                        atLeastOneChanged = true;
                    }
                } else {
                    final AutofillValue initialValue = getValueFromContextsLocked(id);
                    if (sDebug) {
                        Slog.d(TAG, "no current value for " + id + "; initial value is " + initialValue);
                    }
                    if (initialValue != null) {
                        currentValues.put(id, initialValue);
                    }
                }
            }
        }
        if (atLeastOneChanged) {
            if (sDebug) {
                Slog.d(TAG, "at least one field changed, validate fields for save UI");
            }
            final InternalValidator validator = saveInfo.getValidator();
            if (validator != null) {
                final LogMaker log = newLogMaker(MetricsEvent.AUTOFILL_SAVE_VALIDATION);
                boolean isValid;
                try {
                    isValid = validator.isValid(this);
                    if (sDebug)
                        Slog.d(TAG, validator + " returned " + isValid);
                    log.setType(isValid ? MetricsEvent.TYPE_SUCCESS : MetricsEvent.TYPE_DISMISS);
                } catch (Exception e) {
                    Slog.e(TAG, "Not showing save UI because validation failed:", e);
                    log.setType(MetricsEvent.TYPE_FAILURE);
                    mMetricsLogger.write(log);
                    return true;
                }
                mMetricsLogger.write(log);
                if (!isValid) {
                    Slog.i(TAG, "not showing save UI because fields failed validation");
                    return true;
                }
            }
            final List<Dataset> datasets = response.getDatasets();
            if (datasets != null) {
                datasets_loop: for (int i = 0; i < datasets.size(); i++) {
                    final Dataset dataset = datasets.get(i);
                    final ArrayMap<AutofillId, AutofillValue> datasetValues = Helper.getFields(dataset);
                    if (sVerbose) {
                        Slog.v(TAG, "Checking if saved fields match contents of dataset #" + i + ": " + dataset + "; savableIds=" + savableIds);
                    }
                    savable_ids_loop: for (int j = 0; j < savableIds.size(); j++) {
                        final AutofillId id = savableIds.valueAt(j);
                        final AutofillValue currentValue = currentValues.get(id);
                        if (currentValue == null) {
                            if (sDebug) {
                                Slog.d(TAG, "dataset has value for field that is null: " + id);
                            }
                            continue savable_ids_loop;
                        }
                        final AutofillValue datasetValue = datasetValues.get(id);
                        if (!currentValue.equals(datasetValue)) {
                            if (sDebug) {
                                Slog.d(TAG, "found a dataset change on id " + id + ": from " + datasetValue + " to " + currentValue);
                            }
                            continue datasets_loop;
                        }
                        if (sVerbose)
                            Slog.v(TAG, "no dataset changes for id " + id);
                    }
                    if (sDebug) {
                        Slog.d(TAG, "ignoring Save UI because all fields match contents of " + "dataset #" + i + ": " + dataset);
                    }
                    return true;
                }
            }
            if (sDebug) {
                Slog.d(TAG, "Good news, everyone! All checks passed, show save UI for " + id + "!");
            }
            mHandler.sendMessage(obtainMessage(Session::logSaveShown, this));
            final IAutoFillManagerClient client = getClient();
            mPendingSaveUi = new PendingUi(new Binder(), id, client);
            final CharSequence serviceLabel;
            final Drawable serviceIcon;
            synchronized (mLock) {
                serviceLabel = mService.getServiceLabelLocked();
                serviceIcon = mService.getServiceIconLocked();
            }
            if (serviceLabel == null || serviceIcon == null) {
                wtf(null, "showSaveLocked(): no service label or icon");
                return true;
            }
            getUiForShowing().showSaveUi(serviceLabel, serviceIcon, mService.getServicePackageName(), saveInfo, this, mComponentName, this, mPendingSaveUi, isUpdate, mCompatMode);
            if (client != null) {
                try {
                    client.setSaveUiState(id, true);
                } catch (RemoteException e) {
                    Slog.e(TAG, "Error notifying client to set save UI state to shown: " + e);
                }
            }
            mIsSaving = true;
            return false;
        }
    }
    if (sDebug) {
        Slog.d(TAG, "showSaveLocked(" + id + "): with no changes, comes no responsibilities." + "allRequiredAreNotNull=" + allRequiredAreNotEmpty + ", atLeastOneChanged=" + atLeastOneChanged);
    }
    return true;
}