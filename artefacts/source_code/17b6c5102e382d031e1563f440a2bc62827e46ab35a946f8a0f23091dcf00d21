public void onBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState){
    if (DEBUG)
        Slog.v(TAG, "onBackup()");
    ByteArrayOutputStream outputBuffer = new ByteArrayOutputStream();
    DataOutputStream outputBufferStream = new DataOutputStream(outputBuffer);
    parseStateFile(oldState);
    if (mStoredIncrementalVersion == null || !mStoredIncrementalVersion.equals(Build.VERSION.INCREMENTAL)) {
        Slog.i(TAG, "Previous metadata " + mStoredIncrementalVersion + " mismatch vs " + Build.VERSION.INCREMENTAL + " - rewriting");
        mExisting.clear();
    }
    try {
        if (DEBUG)
            Slog.v(TAG, "Storing ancestral record version key");
        outputBufferStream.writeInt(ANCESTRAL_RECORD_VERSION);
        writeEntity(data, ANCESTRAL_RECORD_KEY, outputBuffer.toByteArray());
    } catch (IOException e) {
        Slog.e(TAG, "Unable to write package backup data file!");
        return;
    }
    long homeVersion = 0;
    ArrayList<byte[]> homeSigHashes = null;
    PackageInfo homeInfo = null;
    String homeInstaller = null;
    ComponentName home = getPreferredHomeComponent();
    if (home != null) {
        try {
            homeInfo = mPackageManager.getPackageInfoAsUser(home.getPackageName(), PackageManager.GET_SIGNING_CERTIFICATES, mUserId);
            homeInstaller = mPackageManager.getInstallerPackageName(home.getPackageName());
            homeVersion = homeInfo.getLongVersionCode();
            SigningInfo signingInfo = homeInfo.signingInfo;
            if (signingInfo == null) {
                Slog.e(TAG, "Home app has no signing information");
            } else {
                Signature[] homeInfoSignatures = signingInfo.getApkContentsSigners();
                homeSigHashes = BackupUtils.hashSignatureArray(homeInfoSignatures);
            }
        } catch (NameNotFoundException e) {
            Slog.w(TAG, "Can't access preferred home info");
            home = null;
        }
    }
    try {
        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
        final boolean needHomeBackup = (homeVersion != mStoredHomeVersion) || !Objects.equals(home, mStoredHomeComponent) || (home != null && !BackupUtils.signaturesMatch(mStoredHomeSigHashes, homeInfo, pmi));
        if (needHomeBackup) {
            if (DEBUG) {
                Slog.i(TAG, "Home preference changed; backing up new state " + home);
            }
            if (home != null) {
                outputBuffer.reset();
                outputBufferStream.writeUTF(home.flattenToString());
                outputBufferStream.writeLong(homeVersion);
                outputBufferStream.writeUTF(homeInstaller != null ? homeInstaller : "");
                writeSignatureHashArray(outputBufferStream, homeSigHashes);
                writeEntity(data, DEFAULT_HOME_KEY, outputBuffer.toByteArray());
            } else {
                data.writeEntityHeader(DEFAULT_HOME_KEY, -1);
            }
        }
        outputBuffer.reset();
        if (!mExisting.contains(GLOBAL_METADATA_KEY)) {
            if (DEBUG)
                Slog.v(TAG, "Storing global metadata key");
            outputBufferStream.writeInt(Build.VERSION.SDK_INT);
            outputBufferStream.writeUTF(Build.VERSION.INCREMENTAL);
            writeEntity(data, GLOBAL_METADATA_KEY, outputBuffer.toByteArray());
        } else {
            if (DEBUG)
                Slog.v(TAG, "Global metadata key already stored");
            mExisting.remove(GLOBAL_METADATA_KEY);
        }
        for (PackageInfo pkg : mAllPackages) {
            String packName = pkg.packageName;
            if (packName.equals(GLOBAL_METADATA_KEY)) {
                continue;
            } else {
                PackageInfo info = null;
                try {
                    info = mPackageManager.getPackageInfoAsUser(packName, PackageManager.GET_SIGNING_CERTIFICATES, mUserId);
                } catch (NameNotFoundException e) {
                    mExisting.add(packName);
                    continue;
                }
                if (mExisting.contains(packName)) {
                    mExisting.remove(packName);
                    if (info.getLongVersionCode() == mStateVersions.get(packName).versionCode) {
                        continue;
                    }
                }
                SigningInfo signingInfo = info.signingInfo;
                if (signingInfo == null) {
                    Slog.w(TAG, "Not backing up package " + packName + " since it appears to have no signatures.");
                    continue;
                }
                outputBuffer.reset();
                if (info.versionCodeMajor != 0) {
                    outputBufferStream.writeInt(Integer.MIN_VALUE);
                    outputBufferStream.writeLong(info.getLongVersionCode());
                } else {
                    outputBufferStream.writeInt(info.versionCode);
                }
                Signature[] infoSignatures = signingInfo.getApkContentsSigners();
                writeSignatureHashArray(outputBufferStream, BackupUtils.hashSignatureArray(infoSignatures));
                if (DEBUG) {
                    Slog.v(TAG, "+ writing metadata for " + packName + " version=" + info.getLongVersionCode() + " entityLen=" + outputBuffer.size());
                }
                writeEntity(data, packName, outputBuffer.toByteArray());
            }
        }
        if (DEBUG) {
            if (mExisting.size() > 0) {
                StringBuilder sb = new StringBuilder(64);
                sb.append("Preserving metadata for deleted packages:");
                for (String app : mExisting) {
                    sb.append(' ');
                    sb.append(app);
                }
                Slog.v(TAG, sb.toString());
            }
        }
    } catch (IOException e) {
        Slog.e(TAG, "Unable to write package backup data file!");
        return;
    }
    writeStateFile(mAllPackages, home, homeVersion, homeSigHashes, newState);
}