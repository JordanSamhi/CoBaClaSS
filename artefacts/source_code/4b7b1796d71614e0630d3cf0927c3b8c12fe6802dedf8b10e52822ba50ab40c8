public void systemReady(final Runnable goingCallback, @NonNull TimingsTraceAndSlog t){
    t.traceBegin("PhaseActivityManagerReady");
    mSystemServiceManager.preSystemReady();
    synchronized (this) {
        if (mSystemReady) {
            if (goingCallback != null) {
                goingCallback.run();
            }
            t.traceEnd();
            return;
        }
        t.traceBegin("controllersReady");
        mLocalDeviceIdleController = LocalServices.getService(DeviceIdleInternal.class);
        mActivityTaskManager.onSystemReady();
        mUserController.onSystemReady();
        mAppOpsService.systemReady();
        mProcessList.onSystemReady();
        mSystemReady = true;
        t.traceEnd();
    }
    try {
        sTheRealBuildSerial = IDeviceIdentifiersPolicyService.Stub.asInterface(ServiceManager.getService(Context.DEVICE_IDENTIFIERS_SERVICE)).getSerial();
    } catch (RemoteException e) {
    }
    t.traceBegin("killProcesses");
    ArrayList<ProcessRecord> procsToKill = null;
    synchronized (mPidsSelfLocked) {
        for (int i = mPidsSelfLocked.size() - 1; i >= 0; i--) {
            ProcessRecord proc = mPidsSelfLocked.valueAt(i);
            if (!isAllowedWhileBooting(proc.info)) {
                if (procsToKill == null) {
                    procsToKill = new ArrayList<ProcessRecord>();
                }
                procsToKill.add(proc);
            }
        }
    }
    synchronized (this) {
        if (procsToKill != null) {
            for (int i = procsToKill.size() - 1; i >= 0; i--) {
                ProcessRecord proc = procsToKill.get(i);
                Slog.i(TAG, "Removing system update proc: " + proc);
                mProcessList.removeProcessLocked(proc, true, false, ApplicationExitInfo.REASON_OTHER, ApplicationExitInfo.SUBREASON_SYSTEM_UPDATE_DONE, "system update done");
            }
        }
        mProcessesReady = true;
    }
    t.traceEnd();
    Slog.i(TAG, "System now ready");
    EventLogTags.writeBootProgressAmsReady(SystemClock.uptimeMillis());
    t.traceBegin("updateTopComponentForFactoryTest");
    mAtmInternal.updateTopComponentForFactoryTest();
    t.traceEnd();
    t.traceBegin("registerActivityLaunchObserver");
    mAtmInternal.getLaunchObserverRegistry().registerLaunchObserver(mActivityLaunchObserver);
    t.traceEnd();
    t.traceBegin("watchDeviceProvisioning");
    watchDeviceProvisioning(mContext);
    t.traceEnd();
    t.traceBegin("retrieveSettings");
    retrieveSettings();
    t.traceEnd();
    t.traceBegin("Ugm.onSystemReady");
    mUgmInternal.onSystemReady();
    t.traceEnd();
    t.traceBegin("updateForceBackgroundCheck");
    final PowerManagerInternal pmi = LocalServices.getService(PowerManagerInternal.class);
    if (pmi != null) {
        pmi.registerLowPowerModeObserver(ServiceType.FORCE_BACKGROUND_CHECK, state -> updateForceBackgroundCheck(state.batterySaverEnabled));
        updateForceBackgroundCheck(pmi.getLowPowerState(ServiceType.FORCE_BACKGROUND_CHECK).batterySaverEnabled);
    } else {
        Slog.wtf(TAG, "PowerManagerInternal not found.");
    }
    t.traceEnd();
    if (goingCallback != null)
        goingCallback.run();
    t.traceBegin("getCurrentUser");
    final int currentUserId = mUserController.getCurrentUserId();
    Slog.i(TAG, "Current user:" + currentUserId);
    if (currentUserId != UserHandle.USER_SYSTEM && !mUserController.isSystemUserStarted()) {
        throw new RuntimeException("System user not started while current user is:" + currentUserId);
    }
    t.traceEnd();
    t.traceBegin("ActivityManagerStartApps");
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START, Integer.toString(currentUserId), currentUserId);
    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START, Integer.toString(currentUserId), currentUserId);
    final boolean bootingSystemUser = currentUserId == UserHandle.USER_SYSTEM;
    if (bootingSystemUser) {
        mSystemServiceManager.startUser(t, currentUserId);
    }
    synchronized (this) {
        t.traceBegin("startPersistentApps");
        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);
        t.traceEnd();
        mBooting = true;
        if (UserManager.isSplitSystemUser() && Settings.Secure.getInt(mContext.getContentResolver(), Settings.Secure.USER_SETUP_COMPLETE, 0) != 0 || SystemProperties.getBoolean(SYSTEM_USER_HOME_NEEDED, false)) {
            t.traceBegin("enableHomeActivity");
            ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class);
            try {
                AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM);
            } catch (RemoteException e) {
                throw e.rethrowAsRuntimeException();
            }
            t.traceEnd();
        }
        if (bootingSystemUser) {
            t.traceBegin("startHomeOnAllDisplays");
            mAtmInternal.startHomeOnAllDisplays(currentUserId, "systemReady");
            t.traceEnd();
        }
        t.traceBegin("showSystemReadyErrorDialogs");
        mAtmInternal.showSystemReadyErrorDialogsIfNeeded();
        t.traceEnd();
        if (bootingSystemUser) {
            t.traceBegin("sendUserStartBroadcast");
            final int callingUid = Binder.getCallingUid();
            final int callingPid = Binder.getCallingPid();
            long ident = Binder.clearCallingIdentity();
            try {
                Intent intent = new Intent(Intent.ACTION_USER_STARTED);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY | Intent.FLAG_RECEIVER_FOREGROUND);
                intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
                broadcastIntentLocked(null, null, null, intent, null, null, 0, null, null, null, OP_NONE, null, false, false, MY_PID, SYSTEM_UID, callingUid, callingPid, currentUserId);
                intent = new Intent(Intent.ACTION_USER_STARTING);
                intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);
                intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);
                broadcastIntentLocked(null, null, null, intent, null, new IIntentReceiver.Stub() {

                    @Override
                    public void performReceive(Intent intent, int resultCode, String data, Bundle extras, boolean ordered, boolean sticky, int sendingUser) {
                    }
                }, 0, null, null, new String[] { INTERACT_ACROSS_USERS }, OP_NONE, null, true, false, MY_PID, SYSTEM_UID, callingUid, callingPid, UserHandle.USER_ALL);
            } catch (Throwable e) {
                Slog.wtf(TAG, "Failed sending first user broadcasts", e);
            } finally {
                Binder.restoreCallingIdentity(ident);
            }
            t.traceEnd();
        } else {
            Slog.i(TAG, "Not sending multi-user broadcasts for non-system user " + currentUserId);
        }
        t.traceBegin("resumeTopActivities");
        mAtmInternal.resumeTopActivities(false);
        t.traceEnd();
        if (bootingSystemUser) {
            t.traceBegin("sendUserSwitchBroadcasts");
            mUserController.sendUserSwitchBroadcasts(-1, currentUserId);
            t.traceEnd();
        }
        t.traceBegin("setBinderProxies");
        BinderInternal.nSetBinderProxyCountWatermarks(BINDER_PROXY_HIGH_WATERMARK, BINDER_PROXY_LOW_WATERMARK);
        BinderInternal.nSetBinderProxyCountEnabled(true);
        BinderInternal.setBinderProxyCountCallback((uid) -> {
            Slog.wtf(TAG, "Uid " + uid + " sent too many Binders to uid " + Process.myUid());
            BinderProxy.dumpProxyDebugInfo();
            if (uid == Process.SYSTEM_UID) {
                Slog.i(TAG, "Skipping kill (uid is SYSTEM)");
            } else {
                killUid(UserHandle.getAppId(uid), UserHandle.getUserId(uid), "Too many Binders sent to SYSTEM");
            }
        }, mHandler);
        t.traceEnd();
        t.traceEnd();
        t.traceEnd();
    }
}