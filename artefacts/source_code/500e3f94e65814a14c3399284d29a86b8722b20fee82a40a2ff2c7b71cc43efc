public static MeasuredParagraph buildForStaticLayout(@NonNull TextPaint paint, @NonNull CharSequence text, @IntRange(from = 0) int start, @IntRange(from = 0) int end, @NonNull TextDirectionHeuristic textDir, boolean computeHyphenation, boolean computeLayout, @Nullable MeasuredParagraph hint, @Nullable MeasuredParagraph recycle){
    final MeasuredParagraph mt = recycle == null ? obtain() : recycle;
    mt.resetAndAnalyzeBidi(text, start, end, textDir);
    final MeasuredText.Builder builder;
    if (hint == null) {
        builder = new MeasuredText.Builder(mt.mCopiedBuffer).setComputeHyphenation(computeHyphenation).setComputeLayout(computeLayout);
    } else {
        builder = new MeasuredText.Builder(hint.mMeasuredText);
    }
    if (mt.mTextLength == 0) {
        mt.mMeasuredText = builder.build();
    } else {
        if (mt.mSpanned == null) {
            mt.applyMetricsAffectingSpan(paint, null, start, end, builder);
            mt.mSpanEndCache.append(end);
        } else {
            int spanEnd;
            for (int spanStart = start; spanStart < end; spanStart = spanEnd) {
                spanEnd = mt.mSpanned.nextSpanTransition(spanStart, end, MetricAffectingSpan.class);
                MetricAffectingSpan[] spans = mt.mSpanned.getSpans(spanStart, spanEnd, MetricAffectingSpan.class);
                spans = TextUtils.removeEmptySpans(spans, mt.mSpanned, MetricAffectingSpan.class);
                mt.applyMetricsAffectingSpan(paint, spans, spanStart, spanEnd, builder);
                mt.mSpanEndCache.append(spanEnd);
            }
        }
        mt.mMeasuredText = builder.build();
    }
    return mt;
}