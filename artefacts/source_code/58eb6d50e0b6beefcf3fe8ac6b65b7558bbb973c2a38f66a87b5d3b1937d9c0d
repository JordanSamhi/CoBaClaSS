public void updateAppearance(){
    if (!mShowNotificationShelf) {
        return;
    }
    mShelfIcons.resetViewStates();
    float shelfStart = getTranslationY();
    float numViewsInShelf = 0.0f;
    View lastChild = mAmbientState.getLastVisibleBackgroundChild();
    mNotGoneIndex = -1;
    float interpolationStart = mMaxLayoutHeight - getIntrinsicHeight() * 2;
    float expandAmount = 0.0f;
    if (shelfStart >= interpolationStart) {
        expandAmount = (shelfStart - interpolationStart) / getIntrinsicHeight();
        expandAmount = Math.min(1.0f, expandAmount);
    }
    int notGoneIndex = 0;
    int colorOfViewBeforeLast = NO_COLOR;
    boolean backgroundForceHidden = false;
    if (mHideBackground && !((ShelfState) getViewState()).hasItemsInStableShelf) {
        backgroundForceHidden = true;
    }
    int colorTwoBefore = NO_COLOR;
    int previousColor = NO_COLOR;
    float transitionAmount = 0.0f;
    float currentScrollVelocity = mAmbientState.getCurrentScrollVelocity();
    boolean scrollingFast = currentScrollVelocity > mScrollFastThreshold || (mAmbientState.isExpansionChanging() && Math.abs(mAmbientState.getExpandingVelocity()) > mScrollFastThreshold);
    boolean scrolling = currentScrollVelocity > 0;
    boolean expandingAnimated = mAmbientState.isExpansionChanging() && !mAmbientState.isPanelTracking();
    int baseZHeight = mAmbientState.getBaseZHeight();
    int backgroundTop = 0;
    int clipTopAmount = 0;
    float firstElementRoundness = 0.0f;
    ActivatableNotificationView previousAnv = null;
    for (int i = 0; i < mHostLayout.getChildCount(); i++) {
        ExpandableView child = (ExpandableView) mHostLayout.getChildAt(i);
        if (!child.needsClippingToShelf() || child.getVisibility() == GONE) {
            continue;
        }
        float notificationClipEnd;
        boolean aboveShelf = ViewState.getFinalTranslationZ(child) > baseZHeight || child.isPinned();
        boolean isLastChild = child == lastChild;
        float rowTranslationY = child.getTranslationY();
        if ((isLastChild && !child.isInShelf()) || aboveShelf || backgroundForceHidden) {
            notificationClipEnd = shelfStart + getIntrinsicHeight();
        } else {
            notificationClipEnd = shelfStart - mPaddingBetweenElements;
        }
        int clipTop = updateNotificationClipHeight(child, notificationClipEnd, notGoneIndex);
        clipTopAmount = Math.max(clipTop, clipTopAmount);
        float inShelfAmount = updateShelfTransformation(child, expandAmount, scrolling, scrollingFast, expandingAnimated, isLastChild);
        if (child instanceof ExpandableNotificationRow) {
            ExpandableNotificationRow expandableRow = (ExpandableNotificationRow) child;
            numViewsInShelf += inShelfAmount;
            int ownColorUntinted = expandableRow.getBackgroundColorWithoutTint();
            if (rowTranslationY >= shelfStart && mNotGoneIndex == -1) {
                mNotGoneIndex = notGoneIndex;
                setTintColor(previousColor);
                setOverrideTintColor(colorTwoBefore, transitionAmount);
            } else if (mNotGoneIndex == -1) {
                colorTwoBefore = previousColor;
                transitionAmount = inShelfAmount;
            }
            boolean canModifyColor = mAmbientState.isShadeExpanded() && !(mAmbientState.isOnKeyguard() && mBypassController.getBypassEnabled());
            if (isLastChild && canModifyColor) {
                if (colorOfViewBeforeLast == NO_COLOR) {
                    colorOfViewBeforeLast = ownColorUntinted;
                }
                expandableRow.setOverrideTintColor(colorOfViewBeforeLast, inShelfAmount);
            } else {
                colorOfViewBeforeLast = ownColorUntinted;
                expandableRow.setOverrideTintColor(NO_COLOR, 0);
            }
            if (notGoneIndex != 0 || !aboveShelf) {
                expandableRow.setAboveShelf(false);
            }
            if (notGoneIndex == 0) {
                StatusBarIconView icon = expandableRow.getEntry().getIcons().getShelfIcon();
                NotificationIconContainer.IconState iconState = getIconState(icon);
                if (iconState != null && iconState.clampedAppearAmount == 1.0f) {
                    backgroundTop = (int) (child.getTranslationY() - getTranslationY());
                    firstElementRoundness = expandableRow.getCurrentTopRoundness();
                }
            }
            previousColor = ownColorUntinted;
            notGoneIndex++;
        }
        if (child instanceof ActivatableNotificationView) {
            ActivatableNotificationView anv = (ActivatableNotificationView) child;
            if (anv.isFirstInSection() && previousAnv != null && previousAnv.isLastInSection()) {
                float distanceToGapBottom = child.getTranslationY() - getTranslationY();
                float distanceToGapTop = getTranslationY() - (previousAnv.getTranslationY() + previousAnv.getActualHeight());
                if (distanceToGapTop > 0) {
                    firstElementRoundness = (float) Math.min(1.0, distanceToGapTop / mGapHeight);
                    previousAnv.setBottomRoundness(firstElementRoundness, false);
                    backgroundTop = (int) distanceToGapBottom;
                }
            }
            previousAnv = anv;
        }
    }
    clipTransientViews();
    setClipTopAmount(clipTopAmount);
    boolean isHidden = getViewState().hidden || clipTopAmount >= getIntrinsicHeight();
    if (mShowNotificationShelf) {
        setVisibility(isHidden ? View.INVISIBLE : View.VISIBLE);
    }
    setBackgroundTop(backgroundTop);
    setFirstElementRoundness(firstElementRoundness);
    mShelfIcons.setSpeedBumpIndex(mAmbientState.getSpeedBumpIndex());
    mShelfIcons.calculateIconTranslations();
    mShelfIcons.applyIconStates();
    for (int i = 0; i < mHostLayout.getChildCount(); i++) {
        View child = mHostLayout.getChildAt(i);
        if (!(child instanceof ExpandableNotificationRow) || child.getVisibility() == GONE) {
            continue;
        }
        ExpandableNotificationRow row = (ExpandableNotificationRow) child;
        updateIconClipAmount(row);
        updateContinuousClipping(row);
    }
    boolean hideBackground = numViewsInShelf < 1.0f;
    setHideBackground(hideBackground || backgroundForceHidden);
    if (mNotGoneIndex == -1) {
        mNotGoneIndex = notGoneIndex;
    }
}