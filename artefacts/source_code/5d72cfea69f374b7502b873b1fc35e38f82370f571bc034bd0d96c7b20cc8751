public final Parcelable.Creator<?> readParcelableCreator(@Nullable ClassLoader loader){
    String name = readString();
    if (name == null) {
        return null;
    }
    Parcelable.Creator<?> creator;
    HashMap<String, Parcelable.Creator<?>> map;
    synchronized (mCreators) {
        map = mCreators.get(loader);
        if (map == null) {
            map = new HashMap<>();
            mCreators.put(loader, map);
        }
        creator = map.get(name);
    }
    if (creator != null) {
        return creator;
    }
    try {
        ClassLoader parcelableClassLoader = (loader == null ? getClass().getClassLoader() : loader);
        Class<?> parcelableClass = Class.forName(name, false, parcelableClassLoader);
        if (!Parcelable.class.isAssignableFrom(parcelableClass)) {
            throw new BadParcelableException("Parcelable protocol requires subclassing " + "from Parcelable on class " + name);
        }
        Field f = parcelableClass.getField("CREATOR");
        if ((f.getModifiers() & Modifier.STATIC) == 0) {
            throw new BadParcelableException("Parcelable protocol requires " + "the CREATOR object to be static on class " + name);
        }
        Class<?> creatorType = f.getType();
        if (!Parcelable.Creator.class.isAssignableFrom(creatorType)) {
            throw new BadParcelableException("Parcelable protocol requires a " + "Parcelable.Creator object called " + "CREATOR on class " + name);
        }
        creator = (Parcelable.Creator<?>) f.get(null);
    } catch (IllegalAccessException e) {
        Log.e(TAG, "Illegal access when unmarshalling: " + name, e);
        throw new BadParcelableException("IllegalAccessException when unmarshalling: " + name);
    } catch (ClassNotFoundException e) {
        Log.e(TAG, "Class not found when unmarshalling: " + name, e);
        throw new BadParcelableException("ClassNotFoundException when unmarshalling: " + name);
    } catch (NoSuchFieldException e) {
        throw new BadParcelableException("Parcelable protocol requires a " + "Parcelable.Creator object called " + "CREATOR on class " + name);
    }
    if (creator == null) {
        throw new BadParcelableException("Parcelable protocol requires a " + "non-null Parcelable.Creator object called " + "CREATOR on class " + name);
    }
    synchronized (mCreators) {
        map.put(name, creator);
    }
    return creator;
}