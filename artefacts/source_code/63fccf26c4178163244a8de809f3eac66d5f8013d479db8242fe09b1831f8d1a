public boolean handleClick(@NonNull TextLinks.TextLinkSpan clickedSpan){
    Preconditions.checkNotNull(clickedSpan);
    if (mText instanceof Spanned) {
        final Spanned spanned = (Spanned) mText;
        final int start = spanned.getSpanStart(clickedSpan);
        final int end = spanned.getSpanEnd(clickedSpan);
        if (start >= 0 && end <= mText.length() && start < end) {
            final TextClassification.Request request = new TextClassification.Request.Builder(mText, start, end).setDefaultLocales(getTextLocales()).build();
            final Supplier<TextClassification> supplier = () -> getTextClassificationSession().classifyText(request);
            final Consumer<TextClassification> consumer = classification -> {
                if (classification != null) {
                    if (!classification.getActions().isEmpty()) {
                        try {
                            classification.getActions().get(0).getActionIntent().send();
                        } catch (PendingIntent.CanceledException e) {
                            Log.e(LOG_TAG, "Error sending PendingIntent", e);
                        }
                    } else {
                        Log.d(LOG_TAG, "No link action to perform");
                    }
                } else {
                    Log.d(LOG_TAG, "Timeout while classifying text");
                }
            };
            CompletableFuture.supplyAsync(supplier).completeOnTimeout(null, 1, TimeUnit.SECONDS).thenAccept(consumer);
            return true;
        }
    }
    return false;
}