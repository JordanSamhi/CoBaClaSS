public static Typeface getFontSync(FontRequest request){
    final String id = request.getIdentifier();
    Typeface cachedTypeface = sTypefaceCache.get(id);
    if (cachedTypeface != null) {
        return cachedTypeface;
    }
    synchronized (sLock) {
        cachedTypeface = sTypefaceCache.get(id);
        if (cachedTypeface != null) {
            return cachedTypeface;
        }
        if (sHandler == null) {
            sThread = new HandlerThread("fonts", Process.THREAD_PRIORITY_BACKGROUND);
            sThread.start();
            sHandler = new Handler(sThread.getLooper());
        }
        final Lock lock = new ReentrantLock();
        final Condition cond = lock.newCondition();
        final AtomicReference<Typeface> holder = new AtomicReference<>();
        final AtomicBoolean waiting = new AtomicBoolean(true);
        final AtomicBoolean timeout = new AtomicBoolean(false);
        sHandler.post(() -> {
            try {
                FontFamilyResult result = fetchFonts(sContext, null, request);
                if (result.getStatusCode() == FontFamilyResult.STATUS_OK) {
                    Typeface typeface = buildTypeface(sContext, null, result.getFonts());
                    if (typeface != null) {
                        sTypefaceCache.put(id, typeface);
                    }
                    holder.set(typeface);
                }
            } catch (NameNotFoundException e) {
            }
            lock.lock();
            try {
                if (!timeout.get()) {
                    waiting.set(false);
                    cond.signal();
                }
            } finally {
                lock.unlock();
            }
        });
        sHandler.removeCallbacks(sReplaceDispatcherThreadRunnable);
        sHandler.postDelayed(sReplaceDispatcherThreadRunnable, THREAD_RENEWAL_THRESHOLD_MS);
        long remaining = TimeUnit.MILLISECONDS.toNanos(SYNC_FONT_FETCH_TIMEOUT_MS);
        lock.lock();
        try {
            if (!waiting.get()) {
                return holder.get();
            }
            for (; ; ) {
                try {
                    remaining = cond.awaitNanos(remaining);
                } catch (InterruptedException e) {
                }
                if (!waiting.get()) {
                    return holder.get();
                }
                if (remaining <= 0) {
                    timeout.set(true);
                    Log.w(TAG, "Remote font fetch timed out: " + request.getProviderAuthority() + "/" + request.getQuery());
                    return null;
                }
            }
        } finally {
            lock.unlock();
        }
    }
}