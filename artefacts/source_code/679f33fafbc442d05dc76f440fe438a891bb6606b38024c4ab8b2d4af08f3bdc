public void reloadConfig(){
    if (!mXmlFile.exists()) {
        return;
    }
    try (FileInputStream stream = new FileInputStream(mXmlFile)) {
        final List<byte[]> crc32DomainList = new ArrayList<>();
        final List<byte[]> sha256DomainList = new ArrayList<>();
        final List<byte[]> crc32IpList = new ArrayList<>();
        final List<byte[]> sha256IpList = new ArrayList<>();
        XmlPullParser parser = Xml.newPullParser();
        parser.setInput(stream, StandardCharsets.UTF_8.name());
        parser.nextTag();
        parser.require(XmlPullParser.START_TAG, null, XmlTags.WATCHLIST_CONFIG);
        while (parser.nextTag() == XmlPullParser.START_TAG) {
            String tagName = parser.getName();
            switch(tagName) {
                case XmlTags.CRC32_DOMAIN:
                    parseHashes(parser, tagName, crc32DomainList);
                    break;
                case XmlTags.CRC32_IP:
                    parseHashes(parser, tagName, crc32IpList);
                    break;
                case XmlTags.SHA256_DOMAIN:
                    parseHashes(parser, tagName, sha256DomainList);
                    break;
                case XmlTags.SHA256_IP:
                    parseHashes(parser, tagName, sha256IpList);
                    break;
                default:
                    Log.w(TAG, "Unknown element: " + parser.getName());
                    XmlUtils.skipCurrentTag(parser);
            }
        }
        parser.require(XmlPullParser.END_TAG, null, XmlTags.WATCHLIST_CONFIG);
        mDomainDigests = new CrcShaDigests(new HarmfulCrcs(crc32DomainList), new HarmfulDigests(sha256DomainList));
        mIpDigests = new CrcShaDigests(new HarmfulCrcs(crc32IpList), new HarmfulDigests(sha256IpList));
        Log.i(TAG, "Reload watchlist done");
    } catch (IllegalStateException | NullPointerException | NumberFormatException | XmlPullParserException | IOException | IndexOutOfBoundsException e) {
        Slog.e(TAG, "Failed parsing xml", e);
    }
}