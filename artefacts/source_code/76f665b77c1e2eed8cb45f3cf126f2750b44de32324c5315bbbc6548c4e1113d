public void setInputMethod(IBinder token, String id){
    if (token == null) {
        if (id == null) {
            return;
        }
        if (Process.myUid() == Process.SYSTEM_UID) {
            Log.w(TAG, "System process should not be calling setInputMethod() because almost " + "always it is a bug under multi-user / multi-profile environment. " + "Consider interacting with InputMethodManagerService directly via " + "LocalServices.");
            return;
        }
        final Context fallbackContext = ActivityThread.currentApplication();
        if (fallbackContext == null) {
            return;
        }
        if (fallbackContext.checkSelfPermission(WRITE_SECURE_SETTINGS) != PackageManager.PERMISSION_GRANTED) {
            return;
        }
        final List<InputMethodInfo> imis = getEnabledInputMethodList();
        final int numImis = imis.size();
        boolean found = false;
        for (int i = 0; i < numImis; ++i) {
            final InputMethodInfo imi = imis.get(i);
            if (id.equals(imi.getId())) {
                found = true;
                break;
            }
        }
        if (!found) {
            Log.e(TAG, "Ignoring setInputMethod(null, " + id + ") because the specified " + "id not found in enabled IMEs.");
            return;
        }
        Log.w(TAG, "The undocumented behavior that setInputMethod() accepts null token " + "when the caller has WRITE_SECURE_SETTINGS is deprecated. This behavior may " + "be completely removed in a future version.  Update secure settings directly " + "instead.");
        final ContentResolver resolver = fallbackContext.getContentResolver();
        Settings.Secure.putInt(resolver, Settings.Secure.SELECTED_INPUT_METHOD_SUBTYPE, NOT_A_SUBTYPE_ID);
        Settings.Secure.putString(resolver, Settings.Secure.DEFAULT_INPUT_METHOD, id);
        return;
    }
    InputMethodPrivilegedOperationsRegistry.get(token).setInputMethod(id);
}