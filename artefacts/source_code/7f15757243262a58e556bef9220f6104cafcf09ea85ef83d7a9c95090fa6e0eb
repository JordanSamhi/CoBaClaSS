public void notifyChange(Uri[] uris, IContentObserver observer, boolean observerWantsSelfNotifications, int flags, int userId, int targetSdkVersion, String callingPackage){
    if (DEBUG) {
        Slog.d(TAG, "Notifying update of " + Arrays.toString(uris) + " for user " + userId + ", observer " + observer + ", flags " + Integer.toHexString(flags));
    }
    final int callingUid = Binder.getCallingUid();
    final int callingPid = Binder.getCallingPid();
    final int callingUserId = UserHandle.getCallingUserId();
    final ObserverCollector collector = new ObserverCollector();
    final ArrayMap<Pair<String, Integer>, String> validatedProviders = new ArrayMap<>();
    for (Uri uri : uris) {
        final int resolvedUserId = handleIncomingUser(uri, callingPid, callingUid, Intent.FLAG_GRANT_WRITE_URI_PERMISSION, true, userId);
        final Pair<String, Integer> provider = Pair.create(uri.getAuthority(), resolvedUserId);
        if (!validatedProviders.containsKey(provider)) {
            final String msg = LocalServices.getService(ActivityManagerInternal.class).checkContentProviderAccess(uri.getAuthority(), resolvedUserId);
            if (msg != null) {
                if (targetSdkVersion >= Build.VERSION_CODES.O) {
                    throw new SecurityException(msg);
                } else {
                    if (msg.startsWith("Failed to find provider")) {
                    } else {
                        Log.w(TAG, "Ignoring notify for " + uri + " from " + callingUid + ": " + msg);
                        continue;
                    }
                }
            }
            final String packageName = getProviderPackageName(uri, resolvedUserId);
            validatedProviders.put(provider, packageName);
        }
        synchronized (mRootNode) {
            final int segmentCount = ObserverNode.countUriSegments(uri);
            mRootNode.collectObserversLocked(uri, segmentCount, 0, observer, observerWantsSelfNotifications, flags, resolvedUserId, collector);
        }
    }
    final long token = clearCallingIdentity();
    try {
        collector.dispatch();
        for (int i = 0; i < validatedProviders.size(); i++) {
            final String authority = validatedProviders.keyAt(i).first;
            final int resolvedUserId = validatedProviders.keyAt(i).second;
            final String packageName = validatedProviders.valueAt(i);
            if ((flags & ContentResolver.NOTIFY_SYNC_TO_NETWORK) != 0) {
                SyncManager syncManager = getSyncManager();
                if (syncManager != null) {
                    syncManager.scheduleLocalSync(null, callingUserId, callingUid, authority, getSyncExemptionForCaller(callingUid), callingUid, callingPid, callingPackage);
                }
            }
            synchronized (mCache) {
                for (Uri uri : uris) {
                    if (Objects.equals(uri.getAuthority(), authority)) {
                        invalidateCacheLocked(resolvedUserId, packageName, uri);
                    }
                }
            }
        }
    } finally {
        Binder.restoreCallingIdentity(token);
    }
}