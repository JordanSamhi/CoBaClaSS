public boolean addOrUpdateProvider(PasspointConfiguration config, int uid, String packageName, boolean isFromSuggestion, boolean isTrusted){
    mWifiMetrics.incrementNumPasspointProviderInstallation();
    if (config == null) {
        Log.e(TAG, "Configuration not provided");
        return false;
    }
    if (!config.validate()) {
        Log.e(TAG, "Invalid configuration");
        return false;
    }
    if (!(isFromSuggestion || isTrusted)) {
        Log.e(TAG, "Set isTrusted to false on a non suggestion passpoint is not allowed");
        return false;
    }
    mWifiCarrierInfoManager.tryUpdateCarrierIdForPasspoint(config);
    PasspointProvider newProvider = mObjectFactory.makePasspointProvider(config, mKeyStore, mWifiCarrierInfoManager, mProviderIndex++, uid, packageName, isFromSuggestion);
    newProvider.setTrusted(isTrusted);
    boolean metricsNoRootCa = false;
    boolean metricsSelfSignedRootCa = false;
    boolean metricsSubscriptionExpiration = false;
    if (config.getCredential().getUserCredential() != null || config.getCredential().getCertCredential() != null) {
        X509Certificate[] x509Certificates = config.getCredential().getCaCertificates();
        if (x509Certificates == null) {
            metricsNoRootCa = true;
        } else {
            try {
                for (X509Certificate certificate : x509Certificates) {
                    verifyCaCert(certificate);
                }
            } catch (CertPathValidatorException e) {
                if (e.getReason() == NO_TRUST_ANCHOR) {
                    metricsSelfSignedRootCa = true;
                }
            } catch (Exception e) {
            }
        }
    }
    if (config.getSubscriptionExpirationTimeMillis() != Long.MIN_VALUE) {
        metricsSubscriptionExpiration = true;
    }
    if (!newProvider.installCertsAndKeys()) {
        Log.e(TAG, "Failed to install certificates and keys to keystore");
        return false;
    }
    if (mProviders.containsKey(config.getUniqueId())) {
        PasspointProvider old = mProviders.get(config.getUniqueId());
        if (isFromSuggestion && !old.getPackageName().equals(packageName)) {
            newProvider.uninstallCertsAndKeys();
            return false;
        }
        Log.d(TAG, "Replacing configuration for FQDN: " + config.getHomeSp().getFqdn() + " and unique ID: " + config.getUniqueId());
        old.uninstallCertsAndKeys();
        mProviders.remove(config.getUniqueId());
        if (!old.equals(newProvider)) {
            mWifiConfigManager.removePasspointConfiguredNetwork(newProvider.getWifiConfig().getKey());
        } else {
            updateWifiConfigInWcmIfPresent(newProvider.getWifiConfig(), uid, packageName, isFromSuggestion);
        }
    }
    newProvider.enableVerboseLogging(mVerboseLoggingEnabled ? 1 : 0);
    mProviders.put(config.getUniqueId(), newProvider);
    mWifiConfigManager.saveToStore(true);
    if (!isFromSuggestion && newProvider.getPackageName() != null) {
        startTrackingAppOpsChange(newProvider.getPackageName(), uid);
    }
    Log.d(TAG, "Added/updated Passpoint configuration for FQDN: " + config.getHomeSp().getFqdn() + " with unique ID: " + config.getUniqueId() + " by UID: " + uid);
    if (metricsNoRootCa) {
        mWifiMetrics.incrementNumPasspointProviderWithNoRootCa();
    }
    if (metricsSelfSignedRootCa) {
        mWifiMetrics.incrementNumPasspointProviderWithSelfSignedRootCa();
    }
    if (metricsSubscriptionExpiration) {
        mWifiMetrics.incrementNumPasspointProviderWithSubscriptionExpiration();
    }
    mWifiMetrics.incrementNumPasspointProviderInstallSuccess();
    return true;
}