public void deliverLocked(Alarm alarm, long nowELAPSED, boolean allowWhileIdle){
    final long workSourceToken = ThreadLocalWorkSource.setUid(getAlarmAttributionUid(alarm));
    try {
        if (alarm.operation != null) {
            mSendCount++;
            try {
                alarm.operation.send(getContext(), 0, mBackgroundIntent.putExtra(Intent.EXTRA_ALARM_COUNT, alarm.count), mDeliveryTracker, mHandler, null, allowWhileIdle ? mIdleOptions : null);
            } catch (PendingIntent.CanceledException e) {
                if (alarm.repeatInterval > 0) {
                    removeImpl(alarm.operation, null);
                }
                mSendFinishCount++;
                return;
            }
        } else {
            mListenerCount++;
            if (RECORD_ALARMS_IN_HISTORY) {
                if (alarm.listener == mTimeTickTrigger) {
                    mTickHistory[mNextTickHistory++] = nowELAPSED;
                    if (mNextTickHistory >= TICK_HISTORY_DEPTH) {
                        mNextTickHistory = 0;
                    }
                }
            }
            try {
                if (DEBUG_LISTENER_CALLBACK) {
                    Slog.v(TAG, "Alarm to uid=" + alarm.uid + " listener=" + alarm.listener.asBinder());
                }
                alarm.listener.doAlarm(this);
                mHandler.sendMessageDelayed(mHandler.obtainMessage(AlarmHandler.LISTENER_TIMEOUT, alarm.listener.asBinder()), mConstants.LISTENER_TIMEOUT);
            } catch (Exception e) {
                if (DEBUG_LISTENER_CALLBACK) {
                    Slog.i(TAG, "Alarm undeliverable to listener " + alarm.listener.asBinder(), e);
                }
                mListenerFinishCount++;
                return;
            }
        }
    } finally {
        ThreadLocalWorkSource.restore(workSourceToken);
    }
    if (DEBUG_WAKELOCK) {
        Slog.d(TAG, "mBroadcastRefCount -> " + (mBroadcastRefCount + 1));
    }
    if (mBroadcastRefCount == 0) {
        setWakelockWorkSource(alarm.workSource, alarm.creatorUid, alarm.statsTag, true);
        mWakeLock.acquire();
        mHandler.obtainMessage(AlarmHandler.REPORT_ALARMS_ACTIVE, 1).sendToTarget();
    }
    final InFlight inflight = new InFlight(AlarmManagerService.this, alarm, nowELAPSED);
    mInFlight.add(inflight);
    mBroadcastRefCount++;
    if (inflight.isBroadcast()) {
        notifyBroadcastAlarmPendingLocked(alarm.uid);
    }
    if (allowWhileIdle) {
        mLastAllowWhileIdleDispatch.put(alarm.creatorUid, nowELAPSED);
        if ((mAppStateTracker == null) || mAppStateTracker.isUidInForeground(alarm.creatorUid)) {
            mUseAllowWhileIdleShortTime.put(alarm.creatorUid, true);
        } else {
            mUseAllowWhileIdleShortTime.put(alarm.creatorUid, false);
        }
        if (RECORD_DEVICE_IDLE_ALARMS) {
            IdleDispatchEntry ent = new IdleDispatchEntry();
            ent.uid = alarm.uid;
            ent.pkg = alarm.packageName;
            ent.tag = alarm.statsTag;
            ent.op = "DELIVER";
            ent.elapsedRealtime = nowELAPSED;
            mAllowWhileIdleDispatches.add(ent);
        }
    }
    if (!isExemptFromAppStandby(alarm)) {
        final Pair<String, Integer> packageUser = Pair.create(alarm.sourcePackage, UserHandle.getUserId(alarm.creatorUid));
        mAppWakeupHistory.recordAlarmForPackage(alarm.sourcePackage, UserHandle.getUserId(alarm.creatorUid), nowELAPSED);
    }
    final BroadcastStats bs = inflight.mBroadcastStats;
    bs.count++;
    if (bs.nesting == 0) {
        bs.nesting = 1;
        bs.startTime = nowELAPSED;
    } else {
        bs.nesting++;
    }
    final FilterStats fs = inflight.mFilterStats;
    fs.count++;
    if (fs.nesting == 0) {
        fs.nesting = 1;
        fs.startTime = nowELAPSED;
    } else {
        fs.nesting++;
    }
    if (alarm.type == ELAPSED_REALTIME_WAKEUP || alarm.type == RTC_WAKEUP) {
        bs.numWakeup++;
        fs.numWakeup++;
        ActivityManager.noteWakeupAlarm(alarm.operation, alarm.workSource, alarm.uid, alarm.packageName, alarm.statsTag);
    }
}