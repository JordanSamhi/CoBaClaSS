public static NetworkStats subtract(NetworkStats left, NetworkStats right, NonMonotonicObserver<C> observer, C cookie, NetworkStats recycle){
    long deltaRealtime = left.elapsedRealtime - right.elapsedRealtime;
    if (deltaRealtime < 0) {
        if (observer != null) {
            observer.foundNonMonotonic(left, -1, right, -1, cookie);
        }
        deltaRealtime = 0;
    }
    final Entry entry = new Entry();
    final NetworkStats result;
    if (recycle != null && recycle.capacity >= left.size) {
        result = recycle;
        result.size = 0;
        result.elapsedRealtime = deltaRealtime;
    } else {
        result = new NetworkStats(deltaRealtime, left.size);
    }
    for (int i = 0; i < left.size; i++) {
        entry.iface = left.iface[i];
        entry.uid = left.uid[i];
        entry.set = left.set[i];
        entry.tag = left.tag[i];
        entry.metered = left.metered[i];
        entry.roaming = left.roaming[i];
        entry.defaultNetwork = left.defaultNetwork[i];
        entry.rxBytes = left.rxBytes[i];
        entry.rxPackets = left.rxPackets[i];
        entry.txBytes = left.txBytes[i];
        entry.txPackets = left.txPackets[i];
        entry.operations = left.operations[i];
        final int j = right.findIndexHinted(entry.iface, entry.uid, entry.set, entry.tag, entry.metered, entry.roaming, entry.defaultNetwork, i);
        if (j != -1) {
            entry.rxBytes -= right.rxBytes[j];
            entry.rxPackets -= right.rxPackets[j];
            entry.txBytes -= right.txBytes[j];
            entry.txPackets -= right.txPackets[j];
            entry.operations -= right.operations[j];
        }
        if (entry.isNegative()) {
            if (observer != null) {
                observer.foundNonMonotonic(left, i, right, j, cookie);
            }
            entry.rxBytes = Math.max(entry.rxBytes, 0);
            entry.rxPackets = Math.max(entry.rxPackets, 0);
            entry.txBytes = Math.max(entry.txBytes, 0);
            entry.txPackets = Math.max(entry.txPackets, 0);
            entry.operations = Math.max(entry.operations, 0);
        }
        result.insertEntry(entry);
    }
    return result;
}