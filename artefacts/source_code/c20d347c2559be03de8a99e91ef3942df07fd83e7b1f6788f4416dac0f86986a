public static WallpaperColors fromBitmap(@NonNull Bitmap bitmap){
    if (bitmap == null) {
        throw new IllegalArgumentException("Bitmap can't be null");
    }
    final int bitmapArea = bitmap.getWidth() * bitmap.getHeight();
    boolean shouldRecycle = false;
    if (bitmapArea > MAX_WALLPAPER_EXTRACTION_AREA) {
        shouldRecycle = true;
        Size optimalSize = calculateOptimalSize(bitmap.getWidth(), bitmap.getHeight());
        bitmap = Bitmap.createScaledBitmap(bitmap, optimalSize.getWidth(), optimalSize.getHeight(), true);
    }
    final Palette palette = Palette.from(bitmap).setQuantizer(new VariationalKMeansQuantizer()).maximumColorCount(5).clearFilters().resizeBitmapArea(MAX_WALLPAPER_EXTRACTION_AREA).generate();
    final ArrayList<Palette.Swatch> swatches = new ArrayList<>(palette.getSwatches());
    final float minColorArea = bitmap.getWidth() * bitmap.getHeight() * MIN_COLOR_OCCURRENCE;
    swatches.removeIf(s -> s.getPopulation() < minColorArea);
    swatches.sort((a, b) -> b.getPopulation() - a.getPopulation());
    final int swatchesSize = swatches.size();
    Color primary = null, secondary = null, tertiary = null;
    swatchLoop: for (int i = 0; i < swatchesSize; i++) {
        Color color = Color.valueOf(swatches.get(i).getRgb());
        switch(i) {
            case 0:
                primary = color;
                break;
            case 1:
                secondary = color;
                break;
            case 2:
                tertiary = color;
                break;
            default:
                break swatchLoop;
        }
    }
    int hints = calculateDarkHints(bitmap);
    if (shouldRecycle) {
        bitmap.recycle();
    }
    return new WallpaperColors(primary, secondary, tertiary, HINT_FROM_BITMAP | hints);
}