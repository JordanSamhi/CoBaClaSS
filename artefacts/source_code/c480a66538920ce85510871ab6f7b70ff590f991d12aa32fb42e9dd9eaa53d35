public void expand(Time dtstart, EventRecurrence r, long rangeStartDateValue, long rangeEndDateValue, boolean add, TreeSet<Long> out) throws DateException{
    unsafeNormalize(dtstart);
    long dtstartDateValue = normDateTimeComparisonValue(dtstart);
    int count = 0;
    if (add && dtstartDateValue >= rangeStartDateValue && dtstartDateValue < rangeEndDateValue) {
        out.add(dtstartDateValue);
        ++count;
    }
    Time iterator = mIterator;
    Time until = mUntil;
    StringBuilder sb = mStringBuilder;
    Time generated = mGenerated;
    DaySet days = mDays;
    try {
        days.setRecurrence(r);
        if (rangeEndDateValue == Long.MAX_VALUE && r.until == null && r.count == 0) {
            throw new DateException("No range end provided for a recurrence that has no UNTIL or COUNT.");
        }
        int freqField;
        int freqAmount = r.interval;
        int freq = r.freq;
        switch(freq) {
            case EventRecurrence.SECONDLY:
                freqField = Time.SECOND;
                break;
            case EventRecurrence.MINUTELY:
                freqField = Time.MINUTE;
                break;
            case EventRecurrence.HOURLY:
                freqField = Time.HOUR;
                break;
            case EventRecurrence.DAILY:
                freqField = Time.MONTH_DAY;
                break;
            case EventRecurrence.WEEKLY:
                freqField = Time.MONTH_DAY;
                freqAmount = 7 * r.interval;
                if (freqAmount <= 0) {
                    freqAmount = 7;
                }
                break;
            case EventRecurrence.MONTHLY:
                freqField = Time.MONTH;
                break;
            case EventRecurrence.YEARLY:
                freqField = Time.YEAR;
                break;
            default:
                throw new DateException("bad freq=" + freq);
        }
        if (freqAmount <= 0) {
            freqAmount = 1;
        }
        int bymonthCount = r.bymonthCount;
        boolean usebymonth = useBYX(freq, EventRecurrence.MONTHLY, bymonthCount);
        boolean useDays = freq >= EventRecurrence.WEEKLY && (r.bydayCount > 0 || r.bymonthdayCount > 0);
        int byhourCount = r.byhourCount;
        boolean usebyhour = useBYX(freq, EventRecurrence.HOURLY, byhourCount);
        int byminuteCount = r.byminuteCount;
        boolean usebyminute = useBYX(freq, EventRecurrence.MINUTELY, byminuteCount);
        int bysecondCount = r.bysecondCount;
        boolean usebysecond = useBYX(freq, EventRecurrence.SECONDLY, bysecondCount);
        iterator.set(dtstart);
        if (freqField == Time.MONTH) {
            if (useDays) {
                iterator.monthDay = 1;
            }
        }
        long untilDateValue;
        if (r.until != null) {
            String untilStr = r.until;
            if (untilStr.length() == 15) {
                untilStr = untilStr + 'Z';
            }
            until.parse(untilStr);
            until.switchTimezone(dtstart.timezone);
            untilDateValue = normDateTimeComparisonValue(until);
        } else {
            untilDateValue = Long.MAX_VALUE;
        }
        sb.ensureCapacity(15);
        sb.setLength(15);
        if (SPEW) {
            Log.i(TAG, "expand called w/ rangeStart=" + rangeStartDateValue + " rangeEnd=" + rangeEndDateValue);
        }
        boolean eventEnded = false;
        int failsafe = 0;
        events: {
            while (true) {
                int monthIndex = 0;
                if (failsafe++ > MAX_ALLOWED_ITERATIONS) {
                    Log.w(TAG, "Recurrence processing stuck with r=" + r + " rangeStart=" + rangeStartDateValue + " rangeEnd=" + rangeEndDateValue);
                    break;
                }
                unsafeNormalize(iterator);
                int iteratorYear = iterator.year;
                int iteratorMonth = iterator.month + 1;
                int iteratorDay = iterator.monthDay;
                int iteratorHour = iterator.hour;
                int iteratorMinute = iterator.minute;
                int iteratorSecond = iterator.second;
                generated.set(iterator);
                if (SPEW)
                    Log.i(TAG, "year=" + generated.year);
                do {
                    int month = usebymonth ? r.bymonth[monthIndex] : iteratorMonth;
                    month--;
                    if (SPEW)
                        Log.i(TAG, "  month=" + month);
                    int dayIndex = 1;
                    int lastDayToExamine = 0;
                    if (useDays) {
                        if (freq == EventRecurrence.WEEKLY) {
                            int weekStartAdj = (iterator.weekDay - EventRecurrence.day2TimeDay(r.wkst) + 7) % 7;
                            dayIndex = iterator.monthDay - weekStartAdj;
                            lastDayToExamine = dayIndex + 6;
                        } else {
                            lastDayToExamine = generated.getActualMaximum(Time.MONTH_DAY);
                        }
                        if (SPEW)
                            Log.i(TAG, "dayIndex=" + dayIndex + " lastDayToExamine=" + lastDayToExamine + " days=" + days);
                    }
                    do {
                        int day;
                        if (useDays) {
                            if (!days.get(iterator, dayIndex)) {
                                dayIndex++;
                                continue;
                            } else {
                                day = dayIndex;
                            }
                        } else {
                            day = iteratorDay;
                        }
                        if (SPEW)
                            Log.i(TAG, "    day=" + day);
                        int hourIndex = 0;
                        do {
                            int hour = usebyhour ? r.byhour[hourIndex] : iteratorHour;
                            if (SPEW)
                                Log.i(TAG, "      hour=" + hour + " usebyhour=" + usebyhour);
                            int minuteIndex = 0;
                            do {
                                int minute = usebyminute ? r.byminute[minuteIndex] : iteratorMinute;
                                if (SPEW)
                                    Log.i(TAG, "        minute=" + minute);
                                int secondIndex = 0;
                                do {
                                    int second = usebysecond ? r.bysecond[secondIndex] : iteratorSecond;
                                    if (SPEW)
                                        Log.i(TAG, "          second=" + second);
                                    generated.set(second, minute, hour, day, month, iteratorYear);
                                    unsafeNormalize(generated);
                                    long genDateValue = normDateTimeComparisonValue(generated);
                                    if (genDateValue >= dtstartDateValue) {
                                        int filtered = filter(r, generated);
                                        if (0 == filtered) {
                                            if (!(dtstartDateValue == genDateValue && add && dtstartDateValue >= rangeStartDateValue && dtstartDateValue < rangeEndDateValue)) {
                                                ++count;
                                            }
                                            if (genDateValue > untilDateValue) {
                                                if (SPEW) {
                                                    Log.i(TAG, "stopping b/c until=" + untilDateValue + " generated=" + genDateValue);
                                                }
                                                break events;
                                            }
                                            if (genDateValue >= rangeEndDateValue) {
                                                if (SPEW) {
                                                    Log.i(TAG, "stopping b/c rangeEnd=" + rangeEndDateValue + " generated=" + generated);
                                                }
                                                break events;
                                            }
                                            if (genDateValue >= rangeStartDateValue) {
                                                if (SPEW) {
                                                    Log.i(TAG, "adding date=" + generated + " filtered=" + filtered);
                                                }
                                                if (add) {
                                                    out.add(genDateValue);
                                                } else {
                                                    out.remove(genDateValue);
                                                }
                                            }
                                            if (r.count > 0 && r.count == count) {
                                                break events;
                                            }
                                        }
                                    }
                                    secondIndex++;
                                } while (usebysecond && secondIndex < bysecondCount);
                                minuteIndex++;
                            } while (usebyminute && minuteIndex < byminuteCount);
                            hourIndex++;
                        } while (usebyhour && hourIndex < byhourCount);
                        dayIndex++;
                    } while (useDays && dayIndex <= lastDayToExamine);
                    monthIndex++;
                } while (usebymonth && monthIndex < bymonthCount);
                int oldDay = iterator.monthDay;
                generated.set(iterator);
                int n = 1;
                while (true) {
                    int value = freqAmount * n;
                    switch(freqField) {
                        case Time.SECOND:
                            iterator.second += value;
                            break;
                        case Time.MINUTE:
                            iterator.minute += value;
                            break;
                        case Time.HOUR:
                            iterator.hour += value;
                            break;
                        case Time.MONTH_DAY:
                            iterator.monthDay += value;
                            break;
                        case Time.MONTH:
                            iterator.month += value;
                            break;
                        case Time.YEAR:
                            iterator.year += value;
                            break;
                        case Time.WEEK_DAY:
                            iterator.monthDay += value;
                            break;
                        case Time.YEAR_DAY:
                            iterator.monthDay += value;
                            break;
                        default:
                            throw new RuntimeException("bad field=" + freqField);
                    }
                    unsafeNormalize(iterator);
                    if (freqField != Time.YEAR && freqField != Time.MONTH) {
                        break;
                    }
                    if (iterator.monthDay == oldDay) {
                        break;
                    }
                    n++;
                    iterator.set(generated);
                }
            }
        }
    } catch (DateException e) {
        Log.w(TAG, "DateException with r=" + r + " rangeStart=" + rangeStartDateValue + " rangeEnd=" + rangeEndDateValue);
        throw e;
    } catch (RuntimeException t) {
        Log.w(TAG, "RuntimeException with r=" + r + " rangeStart=" + rangeStartDateValue + " rangeEnd=" + rangeEndDateValue);
        throw t;
    }
}