public void handleCancel(int token, boolean cancelAll){
    Operation op = null;
    synchronized (mCurrentOpLock) {
        op = mCurrentOperations.get(token);
        if (MORE_DEBUG) {
            if (op == null) {
                Slog.w(TAG, addUserIdToLogMessage(mUserId, "Cancel of token " + Integer.toHexString(token) + " but no op found"));
            }
        }
        int state = (op != null) ? op.state : OP_TIMEOUT;
        if (state == OP_ACKNOWLEDGED) {
            if (DEBUG) {
                Slog.w(TAG, addUserIdToLogMessage(mUserId, "Operation already got an ack." + "Should have been removed from mCurrentOperations."));
            }
            op = null;
            mCurrentOperations.delete(token);
        } else if (state == OP_PENDING) {
            if (DEBUG) {
                Slog.v(TAG, addUserIdToLogMessage(mUserId, "Cancel: token=" + Integer.toHexString(token)));
            }
            op.state = OP_TIMEOUT;
            if (op.type == OP_TYPE_BACKUP_WAIT || op.type == OP_TYPE_RESTORE_WAIT) {
                mBackupHandler.removeMessages(getMessageIdForOperationType(op.type));
            }
        }
        mCurrentOpLock.notifyAll();
    }
    if (op != null && op.callback != null) {
        if (MORE_DEBUG) {
            Slog.v(TAG, addUserIdToLogMessage(mUserId, "   Invoking cancel on " + op.callback));
        }
        op.callback.handleCancel(cancelAll);
    }
}