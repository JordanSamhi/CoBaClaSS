public void exitPip(int animationDurationMs){
    if (!mInPip || mExitingPip || mToken == null) {
        Log.wtf(TAG, "Not allowed to exitPip in current state" + " mInPip=" + mInPip + " mExitingPip=" + mExitingPip + " mToken=" + mToken);
        return;
    }
    final Configuration initialConfig = mInitialState.remove(mToken.asBinder());
    final boolean orientationDiffers = initialConfig.windowConfiguration.getRotation() != mPipBoundsHandler.getDisplayRotation();
    final WindowContainerTransaction wct = new WindowContainerTransaction();
    final Rect destinationBounds = initialConfig.windowConfiguration.getBounds();
    final int direction = syncWithSplitScreenBounds(destinationBounds) ? TRANSITION_DIRECTION_TO_SPLIT_SCREEN : TRANSITION_DIRECTION_TO_FULLSCREEN;
    if (orientationDiffers) {
        sendOnPipTransitionStarted(direction);
        applyWindowingModeChangeOnExit(wct, direction);
        WindowOrganizer.applyTransaction(wct);
        sendOnPipTransitionFinished(direction);
        mInPip = false;
    } else {
        final SurfaceControl.Transaction tx = mSurfaceControlTransactionFactory.getTransaction();
        mSurfaceTransactionHelper.scale(tx, mLeash, destinationBounds, mLastReportedBounds);
        tx.setWindowCrop(mLeash, destinationBounds.width(), destinationBounds.height());
        wct.setActivityWindowingMode(mToken, direction == TRANSITION_DIRECTION_TO_SPLIT_SCREEN ? WINDOWING_MODE_SPLIT_SCREEN_SECONDARY : WINDOWING_MODE_FULLSCREEN);
        wct.setBounds(mToken, destinationBounds);
        wct.setBoundsChangeTransaction(mToken, tx);
        applySyncTransaction(wct, new WindowContainerTransactionCallback() {

            @Override
            public void onTransactionReady(int id, SurfaceControl.Transaction t) {
                t.apply();
                scheduleAnimateResizePip(mLastReportedBounds, destinationBounds, null, direction, animationDurationMs, null);
                mInPip = false;
            }
        });
    }
    mExitingPip = true;
}