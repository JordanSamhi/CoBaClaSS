public void onFillRequestSuccess(int requestId, @Nullable FillResponse response, @NonNull String servicePackageName, int requestFlags){
    final AutofillId[] fieldClassificationIds;
    final LogMaker requestLog;
    synchronized (mLock) {
        if (mDestroyed) {
            Slog.w(TAG, "Call to Session#onFillRequestSuccess() rejected - session: " + id + " destroyed");
            return;
        }
        requestLog = mRequestLogs.get(requestId);
        if (requestLog != null) {
            requestLog.setType(MetricsEvent.TYPE_SUCCESS);
        } else {
            Slog.w(TAG, "onFillRequestSuccess(): no request log for id " + requestId);
        }
        if (response == null) {
            if (requestLog != null) {
                requestLog.addTaggedData(MetricsEvent.FIELD_AUTOFILL_NUM_DATASETS, -1);
            }
            processNullResponseLocked(requestId, requestFlags);
            return;
        }
        fieldClassificationIds = response.getFieldClassificationIds();
        if (fieldClassificationIds != null && !mService.isFieldClassificationEnabledLocked()) {
            Slog.w(TAG, "Ignoring " + response + " because field detection is disabled");
            processNullResponseLocked(requestId, requestFlags);
            return;
        }
    }
    mService.setLastResponse(id, response);
    int sessionFinishedState = 0;
    final long disableDuration = response.getDisableDuration();
    if (disableDuration > 0) {
        final int flags = response.getFlags();
        final boolean disableActivityOnly = (flags & FillResponse.FLAG_DISABLE_ACTIVITY_ONLY) != 0;
        notifyDisableAutofillToClient(disableDuration, disableActivityOnly ? mComponentName : null);
        if (disableActivityOnly) {
            mService.disableAutofillForActivity(mComponentName, disableDuration, id, mCompatMode);
        } else {
            mService.disableAutofillForApp(mComponentName.getPackageName(), disableDuration, id, mCompatMode);
        }
        if (triggerAugmentedAutofillLocked(requestFlags) != null) {
            mForAugmentedAutofillOnly = true;
            if (sDebug) {
                Slog.d(TAG, "Service disabled autofill for " + mComponentName + ", but session is kept for augmented autofill only");
            }
            return;
        }
        if (sDebug) {
            final StringBuilder message = new StringBuilder("Service disabled autofill for ").append(mComponentName).append(": flags=").append(flags).append(", duration=");
            TimeUtils.formatDuration(disableDuration, message);
            Slog.d(TAG, message.toString());
        }
        sessionFinishedState = AutofillManager.STATE_DISABLED_BY_SERVICE;
    }
    if (((response.getDatasets() == null || response.getDatasets().isEmpty()) && response.getAuthentication() == null) || disableDuration > 0) {
        notifyUnavailableToClient(sessionFinishedState, null);
        synchronized (mLock) {
            mInlineSessionController.setInlineFillUiLocked(InlineFillUi.emptyUi(mCurrentViewId));
        }
    }
    if (requestLog != null) {
        requestLog.addTaggedData(MetricsEvent.FIELD_AUTOFILL_NUM_DATASETS, response.getDatasets() == null ? 0 : response.getDatasets().size());
        if (fieldClassificationIds != null) {
            requestLog.addTaggedData(MetricsEvent.FIELD_AUTOFILL_NUM_FIELD_CLASSIFICATION_IDS, fieldClassificationIds.length);
        }
    }
    synchronized (mLock) {
        processResponseLocked(response, null, requestFlags);
    }
}