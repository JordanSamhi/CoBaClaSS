public float flingStackThenSpringToEdge(float x, float velX, float velY){
    final boolean stackOnLeftSide = x - mBubbleBitmapSize / 2 < mLayout.getWidth() / 2;
    final boolean stackShouldFlingLeft = stackOnLeftSide ? velX < ESCAPE_VELOCITY : velX < -ESCAPE_VELOCITY;
    final RectF stackBounds = getAllowableStackPositionRegion();
    final float destinationRelativeX = stackShouldFlingLeft ? stackBounds.left : stackBounds.right;
    if (mLayout == null || mLayout.getChildCount() == 0) {
        return destinationRelativeX;
    }
    final ContentResolver contentResolver = mLayout.getContext().getContentResolver();
    final float stiffness = Settings.Secure.getFloat(contentResolver, "bubble_stiffness", SPRING_AFTER_FLING_STIFFNESS);
    final float dampingRatio = Settings.Secure.getFloat(contentResolver, "bubble_damping", SPRING_AFTER_FLING_DAMPING_RATIO);
    final float friction = Settings.Secure.getFloat(contentResolver, "bubble_friction", FLING_FRICTION);
    final float minimumVelocityToReachEdge = (destinationRelativeX - x) * (friction * 4.2f);
    final float estimatedY = PhysicsAnimator.estimateFlingEndValue(mStackPosition.y, velY, new PhysicsAnimator.FlingConfig(friction, stackBounds.top, stackBounds.bottom));
    notifyFloatingCoordinatorStackAnimatingTo(destinationRelativeX, estimatedY);
    final float startXVelocity = stackShouldFlingLeft ? Math.min(minimumVelocityToReachEdge, velX) : Math.max(minimumVelocityToReachEdge, velX);
    flingThenSpringFirstBubbleWithStackFollowing(DynamicAnimation.TRANSLATION_X, startXVelocity, friction, new SpringForce().setStiffness(stiffness).setDampingRatio(dampingRatio), destinationRelativeX);
    flingThenSpringFirstBubbleWithStackFollowing(DynamicAnimation.TRANSLATION_Y, velY, friction, new SpringForce().setStiffness(stiffness).setDampingRatio(dampingRatio), null);
    mFirstBubbleSpringingToTouch = false;
    mIsMovingFromFlinging = true;
    return destinationRelativeX;
}