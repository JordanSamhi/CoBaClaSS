public void dumpAggregatedProtoForStatsd(ProtoOutputStream[] protoStreams, long maxRawShardSizeBytes){
    int shardIndex = 0;
    dumpProtoPreamble(protoStreams[shardIndex]);
    final ArrayMap<String, SparseArray<ProcessState>> procMap = mProcesses.getMap();
    final ProcessMap<ArraySet<PackageState>> procToPkgMap = new ProcessMap<>();
    final SparseArray<ArraySet<String>> uidToPkgMap = new SparseArray<>();
    collectProcessPackageMaps(null, false, procToPkgMap, uidToPkgMap);
    for (int ip = 0; ip < procMap.size(); ip++) {
        final String procName = procMap.keyAt(ip);
        if (protoStreams[shardIndex].getRawSize() > maxRawShardSizeBytes) {
            shardIndex++;
            if (shardIndex >= protoStreams.length) {
                Slog.d(TAG, String.format("Dropping process indices from %d to %d from " + "statsd proto (too large)", ip, procMap.size()));
                break;
            }
            dumpProtoPreamble(protoStreams[shardIndex]);
        }
        final SparseArray<ProcessState> uids = procMap.valueAt(ip);
        for (int iu = 0; iu < uids.size(); iu++) {
            final int uid = uids.keyAt(iu);
            final ProcessState procState = uids.valueAt(iu);
            procState.dumpAggregatedProtoForStatsd(protoStreams[shardIndex], ProcessStatsSectionProto.PROCESS_STATS, procName, uid, mTimePeriodEndRealtime, procToPkgMap, uidToPkgMap);
        }
    }
    for (int i = 0; i <= shardIndex; i++) {
        protoStreams[i].flush();
    }
}