public int dexoptSystemServer(DexoptOptions options){
    if (!PLATFORM_PACKAGE_NAME.equals(options.getPackageName())) {
        Slog.wtf(TAG, "Non system server package used when trying to dexopt system server:" + options.getPackageName());
        return PackageDexOptimizer.DEX_OPT_FAILED;
    }
    DexoptOptions overriddenOptions = options.overrideCompilerFilter(SYSTEM_SERVER_COMPILER_FILTER);
    PackageDexOptimizer pdo = getPackageDexOptimizer(overriddenOptions);
    String packageName = overriddenOptions.getPackageName();
    PackageUseInfo useInfo = getPackageUseInfoOrDefault(packageName);
    if (useInfo.getDexUseInfoMap().isEmpty()) {
        if (DEBUG) {
            Slog.d(TAG, "No dex files recorded for system server");
        }
        return PackageDexOptimizer.DEX_OPT_SKIPPED;
    }
    boolean usageUpdated = false;
    int result = PackageDexOptimizer.DEX_OPT_SKIPPED;
    for (Map.Entry<String, DexUseInfo> entry : useInfo.getDexUseInfoMap().entrySet()) {
        String dexPath = entry.getKey();
        DexUseInfo dexUseInfo = entry.getValue();
        if (!Files.exists(Paths.get(dexPath))) {
            if (DEBUG) {
                Slog.w(TAG, "A dex file previously loaded by System Server does not exist " + " anymore: " + dexPath);
            }
            usageUpdated = mPackageDexUsage.removeDexFile(packageName, dexPath, dexUseInfo.getOwnerUserId()) || usageUpdated;
            continue;
        }
        if (dexUseInfo.isUnsupportedClassLoaderContext() || dexUseInfo.isVariableClassLoaderContext()) {
            String debugMsg = dexUseInfo.isUnsupportedClassLoaderContext() ? "unsupported" : "variable";
            Slog.w(TAG, "Skipping dexopt for system server path loaded with " + debugMsg + " class loader context: " + dexPath);
            continue;
        }
        int newResult = pdo.dexoptSystemServerPath(dexPath, dexUseInfo, overriddenOptions);
        if ((result != PackageDexOptimizer.DEX_OPT_FAILED) && (newResult != PackageDexOptimizer.DEX_OPT_SKIPPED)) {
            result = newResult;
        }
    }
    if (usageUpdated) {
        mPackageDexUsage.maybeWriteAsync();
    }
    return result;
}