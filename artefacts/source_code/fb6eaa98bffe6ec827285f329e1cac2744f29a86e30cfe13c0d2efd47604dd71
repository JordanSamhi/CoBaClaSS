public boolean reset(long uptime, long realtime){
    boolean active = false;
    mOnBatteryBackgroundTimeBase.init(uptime, realtime);
    mOnBatteryScreenOffBackgroundTimeBase.init(uptime, realtime);
    if (mWifiRunningTimer != null) {
        active |= !mWifiRunningTimer.reset(false);
        active |= mWifiRunning;
    }
    if (mFullWifiLockTimer != null) {
        active |= !mFullWifiLockTimer.reset(false);
        active |= mFullWifiLockOut;
    }
    if (mWifiScanTimer != null) {
        active |= !mWifiScanTimer.reset(false);
        active |= mWifiScanStarted;
    }
    if (mWifiBatchedScanTimer != null) {
        for (int i = 0; i < NUM_WIFI_BATCHED_SCAN_BINS; i++) {
            if (mWifiBatchedScanTimer[i] != null) {
                active |= !mWifiBatchedScanTimer[i].reset(false);
            }
        }
        active |= (mWifiBatchedScanBinStarted != NO_BATCHED_SCAN_STARTED);
    }
    if (mWifiMulticastTimer != null) {
        active |= !mWifiMulticastTimer.reset(false);
        active |= (mWifiMulticastWakelockCount > 0);
    }
    active |= !resetIfNotNull(mAudioTurnedOnTimer, false);
    active |= !resetIfNotNull(mVideoTurnedOnTimer, false);
    active |= !resetIfNotNull(mFlashlightTurnedOnTimer, false);
    active |= !resetIfNotNull(mCameraTurnedOnTimer, false);
    active |= !resetIfNotNull(mForegroundActivityTimer, false);
    active |= !resetIfNotNull(mForegroundServiceTimer, false);
    active |= !resetIfNotNull(mAggregatedPartialWakelockTimer, false);
    active |= !resetIfNotNull(mBluetoothScanTimer, false);
    active |= !resetIfNotNull(mBluetoothUnoptimizedScanTimer, false);
    resetIfNotNull(mBluetoothScanResultCounter, false);
    resetIfNotNull(mBluetoothScanResultBgCounter, false);
    if (mProcessStateTimer != null) {
        for (int i = 0; i < NUM_PROCESS_STATE; i++) {
            active |= !resetIfNotNull(mProcessStateTimer[i], false);
        }
        active |= (mProcessState != ActivityManager.PROCESS_STATE_NONEXISTENT);
    }
    if (mVibratorOnTimer != null) {
        if (mVibratorOnTimer.reset(false)) {
            mVibratorOnTimer.detach();
            mVibratorOnTimer = null;
        } else {
            active = true;
        }
    }
    resetIfNotNull(mUserActivityCounters, false);
    resetIfNotNull(mNetworkByteActivityCounters, false);
    resetIfNotNull(mNetworkPacketActivityCounters, false);
    resetIfNotNull(mMobileRadioActiveTime, false);
    resetIfNotNull(mMobileRadioActiveCount, false);
    resetIfNotNull(mWifiControllerActivity, false);
    resetIfNotNull(mBluetoothControllerActivity, false);
    resetIfNotNull(mModemControllerActivity, false);
    resetIfNotNull(mUserCpuTime, false);
    resetIfNotNull(mSystemCpuTime, false);
    resetIfNotNull(mCpuClusterSpeedTimesUs, false);
    resetIfNotNull(mCpuFreqTimeMs, false);
    resetIfNotNull(mScreenOffCpuFreqTimeMs, false);
    resetIfNotNull(mCpuActiveTimeMs, false);
    resetIfNotNull(mCpuClusterTimesMs, false);
    resetIfNotNull(mProcStateTimeMs, false);
    resetIfNotNull(mProcStateScreenOffTimeMs, false);
    resetIfNotNull(mMobileRadioApWakeupCount, false);
    resetIfNotNull(mWifiRadioApWakeupCount, false);
    final ArrayMap<String, Wakelock> wakeStats = mWakelockStats.getMap();
    for (int iw = wakeStats.size() - 1; iw >= 0; iw--) {
        Wakelock wl = wakeStats.valueAt(iw);
        if (wl.reset()) {
            wakeStats.removeAt(iw);
        } else {
            active = true;
        }
    }
    mWakelockStats.cleanup();
    final ArrayMap<String, DualTimer> syncStats = mSyncStats.getMap();
    for (int is = syncStats.size() - 1; is >= 0; is--) {
        DualTimer timer = syncStats.valueAt(is);
        if (timer.reset(false)) {
            syncStats.removeAt(is);
            timer.detach();
        } else {
            active = true;
        }
    }
    mSyncStats.cleanup();
    final ArrayMap<String, DualTimer> jobStats = mJobStats.getMap();
    for (int ij = jobStats.size() - 1; ij >= 0; ij--) {
        DualTimer timer = jobStats.valueAt(ij);
        if (timer.reset(false)) {
            jobStats.removeAt(ij);
            timer.detach();
        } else {
            active = true;
        }
    }
    mJobStats.cleanup();
    mJobCompletions.clear();
    resetIfNotNull(mJobsDeferredEventCount, false);
    resetIfNotNull(mJobsDeferredCount, false);
    resetIfNotNull(mJobsFreshnessTimeMs, false);
    resetIfNotNull(mJobsFreshnessBuckets, false);
    for (int ise = mSensorStats.size() - 1; ise >= 0; ise--) {
        Sensor s = mSensorStats.valueAt(ise);
        if (s.reset()) {
            mSensorStats.removeAt(ise);
        } else {
            active = true;
        }
    }
    for (int ip = mProcessStats.size() - 1; ip >= 0; ip--) {
        Proc proc = mProcessStats.valueAt(ip);
        proc.detach();
    }
    mProcessStats.clear();
    for (int i = mPids.size() - 1; i >= 0; i--) {
        Pid pid = mPids.valueAt(i);
        if (pid.mWakeNesting > 0) {
            active = true;
        } else {
            mPids.removeAt(i);
        }
    }
    for (int i = mPackageStats.size() - 1; i >= 0; i--) {
        Pkg p = mPackageStats.valueAt(i);
        p.detach();
    }
    mPackageStats.clear();
    mLastStepUserTime = mLastStepSystemTime = 0;
    mCurStepUserTime = mCurStepSystemTime = 0;
    return !active;
}