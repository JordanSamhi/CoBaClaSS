public void dumpAggregatedProtoForStatsd(ProtoOutputStream proto, long fieldId, String procName, int uid, long now, final ProcessMap<ArraySet<PackageState>> procToPkgMap, final SparseArray<ArraySet<String>> uidToPkgMap){
    SparseLongArray durationByState = new SparseLongArray();
    boolean didCurState = false;
    for (int i = 0; i < mDurations.getKeyCount(); i++) {
        final int key = mDurations.getKeyAt(i);
        final int type = SparseMappingTable.getIdFromKey(key);
        final int aggregatedType = DumpUtils.aggregateCurrentProcessState(type);
        long time = mDurations.getValue(key);
        if (mCurCombinedState == type) {
            didCurState = true;
            time += now - mStartTime;
        }
        int index = durationByState.indexOfKey(aggregatedType);
        if (index >= 0) {
            durationByState.put(aggregatedType, time + durationByState.valueAt(index));
        } else {
            durationByState.put(aggregatedType, time);
        }
    }
    if (!didCurState && mCurCombinedState != STATE_NOTHING) {
        final int aggregatedType = DumpUtils.aggregateCurrentProcessState(mCurCombinedState);
        int index = durationByState.indexOfKey(aggregatedType);
        if (index >= 0) {
            durationByState.put(aggregatedType, (now - mStartTime) + durationByState.valueAt(index));
        } else {
            durationByState.put(aggregatedType, now - mStartTime);
        }
    }
    SparseLongArray meanRssByState = new SparseLongArray();
    SparseLongArray maxRssByState = new SparseLongArray();
    for (int i = 0; i < mPssTable.getKeyCount(); i++) {
        final int key = mPssTable.getKeyAt(i);
        final int type = SparseMappingTable.getIdFromKey(key);
        final int aggregatedType = DumpUtils.aggregateCurrentProcessState(type);
        if (durationByState.indexOfKey(aggregatedType) < 0) {
            continue;
        }
        long[] rssMeanAndMax = mPssTable.getRssMeanAndMax(key);
        long meanTimesDuration = rssMeanAndMax[0] * mDurations.getValueForId((byte) type);
        if (meanRssByState.indexOfKey(aggregatedType) >= 0) {
            meanRssByState.put(aggregatedType, meanTimesDuration + meanRssByState.get(aggregatedType));
        } else {
            meanRssByState.put(aggregatedType, meanTimesDuration);
        }
        if (maxRssByState.indexOfKey(aggregatedType) >= 0 && maxRssByState.get(aggregatedType) < rssMeanAndMax[1]) {
            maxRssByState.put(aggregatedType, rssMeanAndMax[1]);
        } else if (maxRssByState.indexOfKey(aggregatedType) < 0) {
            maxRssByState.put(aggregatedType, rssMeanAndMax[1]);
        }
    }
    for (int i = 0; i < durationByState.size(); i++) {
        int aggregatedKey = durationByState.keyAt(i);
        if (meanRssByState.indexOfKey(aggregatedKey) < 0) {
            continue;
        }
        final long duration = durationByState.get(aggregatedKey);
        meanRssByState.put(aggregatedKey, duration > 0 ? (meanRssByState.get(aggregatedKey) / duration) : meanRssByState.get(aggregatedKey));
    }
    final long token = proto.start(fieldId);
    writeCompressedProcessName(proto, ProcessStatsProto.PROCESS, procName, mPackage, mMultiPackage || (uidToPkgMap.get(mUid).size() > 1));
    proto.write(ProcessStatsProto.UID, uid);
    for (int i = 0; i < durationByState.size(); i++) {
        final long stateToken = proto.start(ProcessStatsProto.STATES);
        final int aggregatedKey = durationByState.keyAt(i);
        DumpUtils.printAggregatedProcStateTagProto(proto, ProcessStatsStateProto.SCREEN_STATE, ProcessStatsStateProto.PROCESS_STATE_AGGREGATED, aggregatedKey);
        proto.write(ProcessStatsStateProto.DURATION_MS, durationByState.get(aggregatedKey));
        ProtoUtils.toAggStatsProto(proto, ProcessStatsStateProto.RSS, 0, 0, 0, (int) meanRssByState.get(aggregatedKey), (int) maxRssByState.get(aggregatedKey));
        proto.end(stateToken);
    }
    mStats.dumpFilteredAssociationStatesProtoForProc(proto, ProcessStatsProto.ASSOCS, now, this, procToPkgMap, uidToPkgMap);
    proto.end(token);
}