public boolean rescanPackageIfNeeded(boolean isNewApp, boolean forceRescan){
    final ShortcutService s = mShortcutUser.mService;
    final long start = s.getStatStartTime();
    final PackageInfo pi;
    try {
        pi = mShortcutUser.mService.getPackageInfo(getPackageName(), getPackageUserId());
        if (pi == null) {
            return false;
        }
        if (!isNewApp && !forceRescan) {
            if ((getPackageInfo().getVersionCode() == pi.getLongVersionCode()) && (getPackageInfo().getLastUpdateTime() == pi.lastUpdateTime) && areAllActivitiesStillEnabled()) {
                return false;
            }
        }
    } finally {
        s.logDurationStat(Stats.PACKAGE_UPDATE_CHECK, start);
    }
    List<ShortcutInfo> newManifestShortcutList = null;
    try {
        newManifestShortcutList = ShortcutParser.parseShortcuts(mShortcutUser.mService, getPackageName(), getPackageUserId(), mShareTargets);
    } catch (IOException | XmlPullParserException e) {
        Slog.e(TAG, "Failed to load shortcuts from AndroidManifest.xml.", e);
    }
    final int manifestShortcutSize = newManifestShortcutList == null ? 0 : newManifestShortcutList.size();
    if (ShortcutService.DEBUG) {
        Slog.d(TAG, String.format("Package %s has %d manifest shortcut(s), and %d share target(s)", getPackageName(), manifestShortcutSize, mShareTargets.size()));
    }
    if (isNewApp && (manifestShortcutSize == 0)) {
        return false;
    }
    if (ShortcutService.DEBUG) {
        Slog.d(TAG, String.format("Package %s %s, version %d -> %d", getPackageName(), (isNewApp ? "added" : "updated"), getPackageInfo().getVersionCode(), pi.getLongVersionCode()));
    }
    getPackageInfo().updateFromPackageInfo(pi);
    final long newVersionCode = getPackageInfo().getVersionCode();
    for (int i = mShortcuts.size() - 1; i >= 0; i--) {
        final ShortcutInfo si = mShortcuts.valueAt(i);
        if (si.getDisabledReason() != ShortcutInfo.DISABLED_REASON_VERSION_LOWER) {
            continue;
        }
        if (getPackageInfo().getBackupSourceVersionCode() > newVersionCode) {
            if (ShortcutService.DEBUG) {
                Slog.d(TAG, String.format("Shortcut %s require version %s, still not restored.", si.getId(), getPackageInfo().getBackupSourceVersionCode()));
            }
            continue;
        }
        Slog.i(TAG, String.format("Restoring shortcut: %s", si.getId()));
        si.clearFlags(ShortcutInfo.FLAG_DISABLED);
        si.setDisabledReason(ShortcutInfo.DISABLED_REASON_NOT_DISABLED);
    }
    if (!isNewApp) {
        Resources publisherRes = null;
        for (int i = mShortcuts.size() - 1; i >= 0; i--) {
            final ShortcutInfo si = mShortcuts.valueAt(i);
            if (si.isDynamic()) {
                if (si.getActivity() == null) {
                    s.wtf("null activity detected.");
                } else if (!s.injectIsMainActivity(si.getActivity(), getPackageUserId())) {
                    Slog.w(TAG, String.format("%s is no longer main activity. Disabling shorcut %s.", getPackageName(), si.getId()));
                    if (disableDynamicWithId(si.getId(), false, ShortcutInfo.DISABLED_REASON_APP_CHANGED) != null) {
                        continue;
                    }
                }
            }
            if (si.hasAnyResources()) {
                if (!si.isOriginallyFromManifest()) {
                    if (publisherRes == null) {
                        publisherRes = getPackageResources();
                        if (publisherRes == null) {
                            break;
                        }
                    }
                    si.lookupAndFillInResourceIds(publisherRes);
                }
                si.setTimestamp(s.injectCurrentTimeMillis());
            }
        }
    }
    publishManifestShortcuts(newManifestShortcutList);
    if (newManifestShortcutList != null) {
        pushOutExcessShortcuts();
    }
    s.verifyStates();
    s.packageShortcutsChanged(getPackageName(), getPackageUserId(), null, null);
    return true;
}