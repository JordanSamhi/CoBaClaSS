public static void getMatchingRecipients(Context context, BaseRecipientAdapter adapter, ArrayList<String> inAddresses, int addressType, Account account, RecipientMatchCallback callback, ChipsUtil.PermissionsCheckListener permissionsCheckListener){
    Queries.Query query;
    if (addressType == QUERY_TYPE_EMAIL) {
        query = Queries.EMAIL;
    } else {
        query = Queries.PHONE;
    }
    int addressesSize = Math.min(MAX_LOOKUPS, inAddresses.size());
    HashSet<String> addresses = new HashSet<String>();
    StringBuilder bindString = new StringBuilder();
    for (int i = 0; i < addressesSize; i++) {
        Rfc822Token[] tokens = Rfc822Tokenizer.tokenize(inAddresses.get(i).toLowerCase());
        addresses.add(tokens.length > 0 ? tokens[0].getAddress() : inAddresses.get(i));
        bindString.append("?");
        if (i < addressesSize - 1) {
            bindString.append(",");
        }
    }
    if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "Doing reverse lookup for " + addresses.toString());
    }
    String[] addressArray = new String[addresses.size()];
    addresses.toArray(addressArray);
    HashMap<String, RecipientEntry> recipientEntries = null;
    Cursor c = null;
    try {
        if (ChipsUtil.hasPermissions(context, permissionsCheckListener)) {
            c = context.getContentResolver().query(query.getContentUri(), query.getProjection(), query.getProjection()[Queries.Query.DESTINATION] + " IN (" + bindString.toString() + ")", addressArray, null);
        }
        recipientEntries = processContactEntries(c, null);
        callback.matchesFound(recipientEntries);
    } finally {
        if (c != null) {
            c.close();
        }
    }
    final Set<String> matchesNotFound = new HashSet<String>();
    getMatchingRecipientsFromDirectoryQueries(context, recipientEntries, addresses, account, matchesNotFound, query, callback, permissionsCheckListener);
    getMatchingRecipientsFromExtensionMatcher(adapter, matchesNotFound, callback);
}