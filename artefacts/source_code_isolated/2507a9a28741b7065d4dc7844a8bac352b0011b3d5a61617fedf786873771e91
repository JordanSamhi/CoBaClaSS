public final int descramble(@NonNull ByteBuffer srcBuf, @NonNull ByteBuffer dstBuf, @NonNull MediaCodec.CryptoInfo cryptoInfo){
    validateInternalStates();
    if (cryptoInfo.numSubSamples <= 0) {
        throw new IllegalArgumentException("Invalid CryptoInfo: invalid numSubSamples=" + cryptoInfo.numSubSamples);
    } else if (cryptoInfo.numBytesOfClearData == null && cryptoInfo.numBytesOfEncryptedData == null) {
        throw new IllegalArgumentException("Invalid CryptoInfo: clearData and encryptedData size arrays are both null!");
    } else if (cryptoInfo.numBytesOfClearData != null && cryptoInfo.numBytesOfClearData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfClearData is too small!");
    } else if (cryptoInfo.numBytesOfEncryptedData != null && cryptoInfo.numBytesOfEncryptedData.length < cryptoInfo.numSubSamples) {
        throw new IllegalArgumentException("Invalid CryptoInfo: numBytesOfEncryptedData is too small!");
    } else if (cryptoInfo.key == null || cryptoInfo.key.length != 16) {
        throw new IllegalArgumentException("Invalid CryptoInfo: key array is invalid!");
    }
    try {
        return native_descramble(cryptoInfo.key[0], cryptoInfo.key[1], cryptoInfo.numSubSamples, cryptoInfo.numBytesOfClearData, cryptoInfo.numBytesOfEncryptedData, srcBuf, srcBuf.position(), srcBuf.limit(), dstBuf, dstBuf.position(), dstBuf.limit());
    } catch (ServiceSpecificException e) {
        MediaCasStateException.throwExceptionIfNeeded(e.errorCode, e.getMessage());
    } catch (RemoteException e) {
        cleanupAndRethrowIllegalState();
    }
    return -1;
}