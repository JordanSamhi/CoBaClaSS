public E removeAt(int index){
    if (index >= mSize && UtilConfig.sThrowExceptionForUpperArrayOutOfBounds) {
        throw new ArrayIndexOutOfBoundsException(index);
    }
    final int oSize = mSize;
    final Object old = mArray[index];
    if (oSize <= 1) {
        if (DEBUG)
            Log.d(TAG, "remove: shrink from " + mHashes.length + " to 0");
        clear();
    } else {
        final int nSize = oSize - 1;
        if (shouldShrink()) {
            final int n = getNewShrunkenSize();
            if (DEBUG)
                Log.d(TAG, "remove: shrink from " + mHashes.length + " to " + n);
            final int[] ohashes = mHashes;
            final Object[] oarray = mArray;
            allocArrays(n);
            if (index > 0) {
                if (DEBUG)
                    Log.d(TAG, "remove: copy from 0-" + index + " to 0");
                System.arraycopy(ohashes, 0, mHashes, 0, index);
                System.arraycopy(oarray, 0, mArray, 0, index);
            }
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: copy from " + (index + 1) + "-" + nSize + " to " + index);
                }
                System.arraycopy(ohashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(oarray, index + 1, mArray, index, nSize - index);
            }
        } else {
            if (index < nSize) {
                if (DEBUG) {
                    Log.d(TAG, "remove: move " + (index + 1) + "-" + nSize + " to " + index);
                }
                System.arraycopy(mHashes, index + 1, mHashes, index, nSize - index);
                System.arraycopy(mArray, index + 1, mArray, index, nSize - index);
            }
            mArray[nSize] = null;
        }
        if (oSize != mSize) {
            throw new ConcurrentModificationException();
        }
        mSize = nSize;
    }
    return (E) old;
}