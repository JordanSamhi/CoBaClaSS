public void onRequestAutofillLocked(int sessionId, @NonNull IAutoFillManagerClient client, int taskId, @NonNull ComponentName activityComponent, @NonNull AutofillId focusedId, @Nullable AutofillValue focusedValue, @Nullable InlineSuggestionsRequest inlineSuggestionsRequest, @Nullable Function<InlineFillUi, Boolean> inlineSuggestionsCallback, @NonNull Runnable onErrorCallback, @Nullable RemoteInlineSuggestionRenderService remoteRenderService, int userId){
    long requestTime = SystemClock.elapsedRealtime();
    AtomicReference<ICancellationSignal> cancellationRef = new AtomicReference<>();
    postAsync(service -> {
        AndroidFuture<Void> requestAutofill = new AndroidFuture<>();
        client.getAugmentedAutofillClient(new IResultReceiver.Stub() {

            @Override
            public void send(int resultCode, Bundle resultData) throws RemoteException {
                final IBinder realClient = resultData.getBinder(AutofillManager.EXTRA_AUGMENTED_AUTOFILL_CLIENT);
                service.onFillRequest(sessionId, realClient, taskId, activityComponent, focusedId, focusedValue, requestTime, inlineSuggestionsRequest, new IFillCallback.Stub() {

                    @Override
                    public void onSuccess(@Nullable List<Dataset> inlineSuggestionsData, @Nullable Bundle clientState, boolean showingFillWindow) {
                        mCallbacks.resetLastResponse();
                        maybeRequestShowInlineSuggestions(sessionId, inlineSuggestionsRequest, inlineSuggestionsData, clientState, focusedId, focusedValue, inlineSuggestionsCallback, client, onErrorCallback, remoteRenderService, userId);
                        if (!showingFillWindow) {
                            requestAutofill.complete(null);
                        }
                    }

                    @Override
                    public boolean isCompleted() {
                        return requestAutofill.isDone() && !requestAutofill.isCancelled();
                    }

                    @Override
                    public void onCancellable(ICancellationSignal cancellation) {
                        if (requestAutofill.isCancelled()) {
                            dispatchCancellation(cancellation);
                        } else {
                            cancellationRef.set(cancellation);
                        }
                    }

                    @Override
                    public void cancel() {
                        requestAutofill.cancel(true);
                    }
                });
            }
        });
        return requestAutofill;
    }).orTimeout(mRequestTimeoutMs, TimeUnit.MILLISECONDS).whenComplete((res, err) -> {
        if (err instanceof CancellationException) {
            dispatchCancellation(cancellationRef.get());
        } else if (err instanceof TimeoutException) {
            Slog.w(TAG, "PendingAutofillRequest timed out (" + mRequestTimeoutMs + "ms) for " + RemoteAugmentedAutofillService.this);
            dispatchCancellation(cancellationRef.get());
            if (mComponentName != null) {
                logResponse(MetricsEvent.TYPE_ERROR, mComponentName.getPackageName(), activityComponent, sessionId, mRequestTimeoutMs);
            }
        } else if (err != null) {
            Slog.e(TAG, "exception handling getAugmentedAutofillClient() for " + sessionId + ": ", err);
        } else {
        }
    });
}