public void showSaveUi(@NonNull CharSequence serviceLabel, @NonNull Drawable serviceIcon, @Nullable String servicePackageName, @NonNull SaveInfo info, @NonNull ValueFinder valueFinder, @NonNull ComponentName componentName, @NonNull AutoFillUiCallback callback, @NonNull PendingUi pendingSaveUi, boolean isUpdate, boolean compatMode){
    if (sVerbose) {
        Slog.v(TAG, "showSaveUi(update=" + isUpdate + ") for " + componentName.toShortString() + ": " + info);
    }
    int numIds = 0;
    numIds += info.getRequiredIds() == null ? 0 : info.getRequiredIds().length;
    numIds += info.getOptionalIds() == null ? 0 : info.getOptionalIds().length;
    final LogMaker log = Helper.newLogMaker(MetricsEvent.AUTOFILL_SAVE_UI, componentName, servicePackageName, pendingSaveUi.sessionId, compatMode).addTaggedData(MetricsEvent.FIELD_AUTOFILL_NUM_IDS, numIds);
    if (isUpdate) {
        log.addTaggedData(MetricsEvent.FIELD_AUTOFILL_UPDATE, 1);
    }
    mHandler.post(() -> {
        if (callback != mCallback) {
            return;
        }
        hideAllUiThread(callback);
        mSaveUiCallback = callback;
        mSaveUi = new SaveUi(mContext, pendingSaveUi, serviceLabel, serviceIcon, servicePackageName, componentName, info, valueFinder, mOverlayControl, new SaveUi.OnSaveListener() {

            @Override
            public void onSave() {
                log.setType(MetricsEvent.TYPE_ACTION);
                hideSaveUiUiThread(callback);
                callback.save();
                destroySaveUiUiThread(pendingSaveUi, true);
            }

            @Override
            public void onCancel(IntentSender listener) {
                log.setType(MetricsEvent.TYPE_DISMISS);
                hideSaveUiUiThread(callback);
                if (listener != null) {
                    try {
                        listener.sendIntent(mContext, 0, null, null, null);
                    } catch (IntentSender.SendIntentException e) {
                        Slog.e(TAG, "Error starting negative action listener: " + listener, e);
                    }
                }
                callback.cancelSave();
                destroySaveUiUiThread(pendingSaveUi, true);
            }

            @Override
            public void onDestroy() {
                if (log.getType() == MetricsEvent.TYPE_UNKNOWN) {
                    log.setType(MetricsEvent.TYPE_CLOSE);
                    callback.cancelSave();
                }
                mMetricsLogger.write(log);
            }

            @Override
            public void startIntentSender(IntentSender intentSender, Intent intent) {
                callback.startIntentSender(intentSender, intent);
            }
        }, mUiModeMgr.isNightMode(), isUpdate, compatMode);
    });
}