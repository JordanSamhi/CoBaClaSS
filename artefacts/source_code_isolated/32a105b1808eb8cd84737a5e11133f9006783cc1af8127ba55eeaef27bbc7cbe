public final KernelWakelockStats readKernelWakelockStats(KernelWakelockStats staleStats){
    boolean useSystemSuspend = (new File(sSysClassWakeupDir)).exists();
    if (useSystemSuspend) {
        updateVersion(staleStats);
        if (getWakelockStatsFromSystemSuspend(staleStats) == null) {
            Slog.w(TAG, "Failed to get wakelock stats from SystemSuspend");
            return null;
        }
        return removeOldStats(staleStats);
    } else {
        Arrays.fill(mKernelWakelockBuffer, (byte) 0);
        int len = 0;
        boolean wakeup_sources;
        final long startTime = SystemClock.uptimeMillis();
        final int oldMask = StrictMode.allowThreadDiskReadsMask();
        try {
            FileInputStream is;
            try {
                is = new FileInputStream(sWakelockFile);
                wakeup_sources = false;
            } catch (java.io.FileNotFoundException e) {
                try {
                    is = new FileInputStream(sWakeupSourceFile);
                    wakeup_sources = true;
                } catch (java.io.FileNotFoundException e2) {
                    Slog.wtf(TAG, "neither " + sWakelockFile + " nor " + sWakeupSourceFile + " exists");
                    return null;
                }
            }
            int cnt;
            while ((cnt = is.read(mKernelWakelockBuffer, len, mKernelWakelockBuffer.length - len)) > 0) {
                len += cnt;
            }
            is.close();
        } catch (java.io.IOException e) {
            Slog.wtf(TAG, "failed to read kernel wakelocks", e);
            return null;
        } finally {
            StrictMode.setThreadPolicyMask(oldMask);
        }
        final long readTime = SystemClock.uptimeMillis() - startTime;
        if (readTime > 100) {
            Slog.w(TAG, "Reading wakelock stats took " + readTime + "ms");
        }
        if (len > 0) {
            if (len >= mKernelWakelockBuffer.length) {
                Slog.wtf(TAG, "Kernel wake locks exceeded mKernelWakelockBuffer size " + mKernelWakelockBuffer.length);
            }
            int i;
            for (i = 0; i < len; i++) {
                if (mKernelWakelockBuffer[i] == '\0') {
                    len = i;
                    break;
                }
            }
        }
        updateVersion(staleStats);
        if (getWakelockStatsFromSystemSuspend(staleStats) == null) {
            Slog.w(TAG, "Failed to get Native wakelock stats from SystemSuspend");
        }
        parseProcWakelocks(mKernelWakelockBuffer, len, wakeup_sources, staleStats);
        return removeOldStats(staleStats);
    }
}