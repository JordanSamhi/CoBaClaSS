public static void waitForProcessDeath(int pid, int timeout) throws InterruptedException, TimeoutException{
    FileDescriptor pidfd = null;
    if (sPidFdSupported == PIDFD_UNKNOWN) {
        int fd = -1;
        try {
            fd = nativePidFdOpen(pid, 0);
            sPidFdSupported = PIDFD_SUPPORTED;
        } catch (ErrnoException e) {
            sPidFdSupported = e.errno != OsConstants.ENOSYS ? PIDFD_SUPPORTED : PIDFD_UNSUPPORTED;
        } finally {
            if (fd >= 0) {
                pidfd = new FileDescriptor();
                pidfd.setInt$(fd);
            }
        }
    }
    boolean fallback = sPidFdSupported == PIDFD_UNSUPPORTED;
    if (!fallback) {
        try {
            if (pidfd == null) {
                int fd = nativePidFdOpen(pid, 0);
                if (fd >= 0) {
                    pidfd = new FileDescriptor();
                    pidfd.setInt$(fd);
                } else {
                    fallback = true;
                }
            }
            if (pidfd != null) {
                StructPollfd[] fds = new StructPollfd[] { new StructPollfd() };
                fds[0].fd = pidfd;
                fds[0].events = (short) OsConstants.POLLIN;
                fds[0].revents = 0;
                fds[0].userData = null;
                int res = Os.poll(fds, timeout);
                if (res > 0) {
                    return;
                } else if (res == 0) {
                    throw new TimeoutException();
                } else {
                }
            }
        } catch (ErrnoException e) {
            if (e.errno == OsConstants.EINTR) {
                throw new InterruptedException();
            }
            fallback = true;
        } finally {
            if (pidfd != null) {
                IoUtils.closeQuietly(pidfd);
            }
        }
    }
    if (fallback) {
        boolean infinity = timeout < 0;
        long now = System.currentTimeMillis();
        final long end = now + timeout;
        while (infinity || now < end) {
            try {
                Os.kill(pid, 0);
            } catch (ErrnoException e) {
                if (e.errno == OsConstants.ESRCH) {
                    return;
                }
            }
            Thread.sleep(1);
            now = System.currentTimeMillis();
        }
    }
    throw new TimeoutException();
}