public void show(@FloatRange(from = 0) float sourceCenterX, @FloatRange(from = 0) float sourceCenterY, float magnifierCenterX, float magnifierCenterY){
    obtainSurfaces();
    obtainContentCoordinates(sourceCenterX, sourceCenterY);
    int startX = mClampedCenterZoomCoords.x - mSourceWidth / 2;
    final int startY = mClampedCenterZoomCoords.y - mSourceHeight / 2;
    if (mIsFishEyeStyle) {
        magnifierCenterX = mClampedCenterZoomCoords.x - mViewCoordinatesInSurface[0];
        magnifierCenterY = mClampedCenterZoomCoords.y - mViewCoordinatesInSurface[1];
        final float rampPre = (mSourceWidth - (mSourceWidth - 2 * mRamp) / mZoom) / 2;
        final float x0 = sourceCenterX - mSourceWidth / 2;
        final float rampX0 = x0 + mRamp;
        float leftEdge = 0;
        if (leftEdge > rampX0) {
            leftEdge = sourceCenterX - (sourceCenterX - leftEdge) / mZoom;
        } else if (leftEdge > x0) {
            leftEdge = x0 + rampPre - (rampX0 - leftEdge) * rampPre / mRamp;
        }
        int leftBound = Math.min(Math.max((int) leftEdge, mLeftBound), mRightBound);
        final float x1 = sourceCenterX + mSourceWidth / 2;
        final float rampX1 = x1 - mRamp;
        float rightEdge = mView.getWidth();
        if (rightEdge < rampX1) {
            rightEdge = sourceCenterX + (rightEdge - sourceCenterX) / mZoom;
        } else if (rightEdge < x1) {
            rightEdge = x1 - rampPre + (rightEdge - rampX1) * rampPre / mRamp;
        }
        int rightBound = Math.max(leftBound, Math.min((int) rightEdge, mRightBound));
        leftBound = Math.max(leftBound + mViewCoordinatesInSurface[0], 0);
        rightBound = Math.min(rightBound + mViewCoordinatesInSurface[0], mContentCopySurface.mWidth);
        mLeftCutWidth = Math.max(0, leftBound - startX);
        mRightCutWidth = Math.max(0, startX + mSourceWidth - rightBound);
        startX = Math.max(startX, leftBound);
    }
    obtainWindowCoordinates(magnifierCenterX, magnifierCenterY);
    if (sourceCenterX != mPrevShowSourceCoords.x || sourceCenterY != mPrevShowSourceCoords.y || mDirtyState) {
        if (mWindow == null) {
            synchronized (mLock) {
                mWindow = new InternalPopupWindow(mView.getContext(), mView.getDisplay(), mParentSurface.mSurfaceControl, mWindowWidth, mWindowHeight, mZoom, mRamp, mWindowElevation, mWindowCornerRadius, mOverlay != null ? mOverlay : new ColorDrawable(Color.TRANSPARENT), Handler.getMain(), mLock, mCallback, mIsFishEyeStyle);
            }
        }
        performPixelCopy(startX, startY, true);
    } else if (magnifierCenterX != mPrevShowWindowCoords.x || magnifierCenterY != mPrevShowWindowCoords.y) {
        final Point windowCoords = getCurrentClampedWindowCoordinates();
        final InternalPopupWindow currentWindowInstance = mWindow;
        sPixelCopyHandlerThread.getThreadHandler().post(() -> {
            synchronized (mLock) {
                if (mWindow != currentWindowInstance) {
                    return;
                }
                mWindow.setContentPositionForNextDraw(windowCoords.x, windowCoords.y);
            }
        });
    }
    mPrevShowSourceCoords.x = sourceCenterX;
    mPrevShowSourceCoords.y = sourceCenterY;
    mPrevShowWindowCoords.x = magnifierCenterX;
    mPrevShowWindowCoords.y = magnifierCenterY;
}