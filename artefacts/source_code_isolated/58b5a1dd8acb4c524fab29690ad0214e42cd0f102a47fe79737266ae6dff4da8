public NetworkStatsHistory getHistory(NetworkTemplate template, SubscriptionPlan augmentPlan, int uid, int set, int tag, int fields, long start, long end, @NetworkStatsAccess.Level int accessLevel, int callerUid){
    if (!NetworkStatsAccess.isAccessibleToUser(uid, callerUid, accessLevel)) {
        throw new SecurityException("Network stats history of uid " + uid + " is forbidden for caller " + callerUid);
    }
    final int bucketEstimate = (int) MathUtils.constrain(((end - start) / mBucketDuration), 0, (180 * DateUtils.DAY_IN_MILLIS) / mBucketDuration);
    final NetworkStatsHistory combined = new NetworkStatsHistory(mBucketDuration, bucketEstimate, fields);
    if (start == end)
        return combined;
    long augmentStart = SubscriptionPlan.TIME_UNKNOWN;
    long augmentEnd = (augmentPlan != null) ? augmentPlan.getDataUsageTime() : SubscriptionPlan.TIME_UNKNOWN;
    long collectStart = start;
    long collectEnd = end;
    if (augmentEnd != SubscriptionPlan.TIME_UNKNOWN) {
        final Iterator<Range<ZonedDateTime>> it = augmentPlan.cycleIterator();
        while (it.hasNext()) {
            final Range<ZonedDateTime> cycle = it.next();
            final long cycleStart = cycle.getLower().toInstant().toEpochMilli();
            final long cycleEnd = cycle.getUpper().toInstant().toEpochMilli();
            if (cycleStart <= augmentEnd && augmentEnd < cycleEnd) {
                augmentStart = cycleStart;
                collectStart = Long.min(collectStart, augmentStart);
                collectEnd = Long.max(collectEnd, augmentEnd);
                break;
            }
        }
    }
    if (augmentStart != SubscriptionPlan.TIME_UNKNOWN) {
        augmentStart = roundUp(augmentStart);
        augmentEnd = roundDown(augmentEnd);
        collectStart = roundDown(collectStart);
        collectEnd = roundUp(collectEnd);
    }
    for (int i = 0; i < mStats.size(); i++) {
        final Key key = mStats.keyAt(i);
        if (key.uid == uid && NetworkStats.setMatches(set, key.set) && key.tag == tag && templateMatches(template, key.ident)) {
            final NetworkStatsHistory value = mStats.valueAt(i);
            combined.recordHistory(value, collectStart, collectEnd);
        }
    }
    if (augmentStart != SubscriptionPlan.TIME_UNKNOWN) {
        final NetworkStatsHistory.Entry entry = combined.getValues(augmentStart, augmentEnd, null);
        if (entry.rxBytes == 0 || entry.txBytes == 0) {
            combined.recordData(augmentStart, augmentEnd, new NetworkStats.Entry(1, 0, 1, 0, 0));
            combined.getValues(augmentStart, augmentEnd, entry);
        }
        final long rawBytes = entry.rxBytes + entry.txBytes;
        final long rawRxBytes = entry.rxBytes;
        final long rawTxBytes = entry.txBytes;
        final long targetBytes = augmentPlan.getDataUsageBytes();
        final long targetRxBytes = multiplySafe(targetBytes, rawRxBytes, rawBytes);
        final long targetTxBytes = multiplySafe(targetBytes, rawTxBytes, rawBytes);
        final long beforeTotal = combined.getTotalBytes();
        for (int i = 0; i < combined.size(); i++) {
            combined.getValues(i, entry);
            if (entry.bucketStart >= augmentStart && entry.bucketStart + entry.bucketDuration <= augmentEnd) {
                entry.rxBytes = multiplySafe(targetRxBytes, entry.rxBytes, rawRxBytes);
                entry.txBytes = multiplySafe(targetTxBytes, entry.txBytes, rawTxBytes);
                entry.rxPackets = 0;
                entry.txPackets = 0;
                combined.setValues(i, entry);
            }
        }
        final long deltaTotal = combined.getTotalBytes() - beforeTotal;
        if (deltaTotal != 0) {
            Slog.d(TAG, "Augmented network usage by " + deltaTotal + " bytes");
        }
        final NetworkStatsHistory sliced = new NetworkStatsHistory(mBucketDuration, bucketEstimate, fields);
        sliced.recordHistory(combined, start, end);
        return sliced;
    } else {
        return combined;
    }
}