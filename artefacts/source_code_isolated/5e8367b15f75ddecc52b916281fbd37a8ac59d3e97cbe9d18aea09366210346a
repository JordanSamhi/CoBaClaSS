public static boolean installApk(InputStream instream, Context context, RestoreDeleteObserver deleteObserver, HashMap<String, Signature[]> manifestSignatures, HashMap<String, RestorePolicy> packagePolicies, FileMetadata info, String installerPackageName, BytesReadListener bytesReadListener, int userId){
    boolean okay = true;
    if (DEBUG) {
        Slog.d(TAG, "Installing from backup: " + info.packageName);
    }
    try {
        LocalIntentReceiver receiver = new LocalIntentReceiver();
        PackageManager packageManager = context.getPackageManager();
        PackageInstaller installer = packageManager.getPackageInstaller();
        SessionParams params = new SessionParams(SessionParams.MODE_FULL_INSTALL);
        params.setInstallerPackageName(installerPackageName);
        int sessionId = installer.createSession(params);
        try {
            try (Session session = installer.openSession(sessionId)) {
                try (OutputStream apkStream = session.openWrite(info.packageName, 0, info.size)) {
                    byte[] buffer = new byte[32 * 1024];
                    long size = info.size;
                    while (size > 0) {
                        long toRead = (buffer.length < size) ? buffer.length : size;
                        int didRead = instream.read(buffer, 0, (int) toRead);
                        if (didRead >= 0) {
                            bytesReadListener.onBytesRead(didRead);
                        }
                        apkStream.write(buffer, 0, didRead);
                        size -= didRead;
                    }
                }
                session.abandon();
            }
        } catch (Exception t) {
            installer.abandonSession(sessionId);
            throw t;
        }
        Intent result = null;
        int status = PackageInstaller.STATUS_FAILURE;
        if (status != PackageInstaller.STATUS_SUCCESS) {
            if (packagePolicies.get(info.packageName) != RestorePolicy.ACCEPT) {
                okay = false;
            }
        } else {
            boolean uninstall = false;
            final String installedPackageName = result.getStringExtra(PackageInstaller.EXTRA_PACKAGE_NAME);
            if (!installedPackageName.equals(info.packageName)) {
                Slog.w(TAG, "Restore stream claimed to include apk for " + info.packageName + " but apk was really " + installedPackageName);
                okay = false;
                uninstall = true;
            } else {
                try {
                    PackageInfo pkg = packageManager.getPackageInfoAsUser(info.packageName, PackageManager.GET_SIGNING_CERTIFICATES, userId);
                    if ((pkg.applicationInfo.flags & ApplicationInfo.FLAG_ALLOW_BACKUP) == 0) {
                        Slog.w(TAG, "Restore stream contains apk of package " + info.packageName + " but it disallows backup/restore");
                        okay = false;
                    } else {
                        Signature[] sigs = manifestSignatures.get(info.packageName);
                        PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);
                        if (AppBackupUtils.signaturesMatch(sigs, pkg, pmi)) {
                            if (UserHandle.isCore(pkg.applicationInfo.uid) && (pkg.applicationInfo.backupAgentName == null)) {
                                Slog.w(TAG, "Installed app " + info.packageName + " has restricted uid and no agent");
                                okay = false;
                            }
                        } else {
                            Slog.w(TAG, "Installed app " + info.packageName + " signatures do not match restore manifest");
                            okay = false;
                            uninstall = true;
                        }
                    }
                } catch (PackageManager.NameNotFoundException e) {
                    Slog.w(TAG, "Install of package " + info.packageName + " succeeded but now not found");
                    okay = false;
                }
            }
            if (uninstall) {
                deleteObserver.reset();
                packageManager.deletePackage(installedPackageName, deleteObserver, 0);
                deleteObserver.waitForCompletion();
            }
        }
    } catch (IOException e) {
        Slog.e(TAG, "Unable to transcribe restored apk for install");
        okay = false;
    }
    return okay;
}