public static JobStatus createFromJobInfo(JobInfo job, int callingUid, String sourcePkg, int sourceUserId, String tag){
    final long elapsedNow = sElapsedRealtimeClock.millis();
    final long earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis;
    if (job.isPeriodic()) {
        final long period = Math.max(JobInfo.getMinPeriodMillis(), Math.min(JobSchedulerService.MAX_ALLOWED_PERIOD_MS, job.getIntervalMillis()));
        latestRunTimeElapsedMillis = elapsedNow + period;
        earliestRunTimeElapsedMillis = latestRunTimeElapsedMillis - Math.max(JobInfo.getMinFlexMillis(), Math.min(period, job.getFlexMillis()));
    } else {
        earliestRunTimeElapsedMillis = job.hasEarlyConstraint() ? elapsedNow + job.getMinLatencyMillis() : NO_EARLIEST_RUNTIME;
        latestRunTimeElapsedMillis = job.hasLateConstraint() ? elapsedNow + job.getMaxExecutionDelayMillis() : NO_LATEST_RUNTIME;
    }
    String jobPackage = (sourcePkg != null) ? sourcePkg : job.getService().getPackageName();
    int standbyBucket = JobSchedulerService.standbyBucketForPackage(jobPackage, sourceUserId, elapsedNow);
    return new JobStatus(job, callingUid, sourcePkg, sourceUserId, standbyBucket, tag, 0, earliestRunTimeElapsedMillis, latestRunTimeElapsedMillis, 0, 0, 0);
}