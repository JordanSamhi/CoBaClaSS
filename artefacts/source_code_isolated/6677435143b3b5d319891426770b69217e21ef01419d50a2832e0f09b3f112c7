public void set(TextPaint paint, CharSequence text, int start, int limit, int dir, Directions directions, boolean hasTabs, TabStops tabStops, int ellipsisStart, int ellipsisEnd){
    mPaint = paint;
    mText = text;
    mStart = start;
    mLen = limit - start;
    mDir = dir;
    mDirections = directions;
    if (mDirections == null) {
        throw new IllegalArgumentException("Directions cannot be null");
    }
    mHasTabs = hasTabs;
    mSpanned = null;
    boolean hasReplacement = false;
    if (text instanceof Spanned) {
        mSpanned = (Spanned) text;
        mReplacementSpanSpanSet.init(mSpanned, start, limit);
        hasReplacement = mReplacementSpanSpanSet.numberOfSpans > 0;
    }
    mComputed = null;
    if (text instanceof PrecomputedText) {
        mComputed = (PrecomputedText) text;
        if (!mComputed.getParams().getTextPaint().equalsForTextMeasurement(paint)) {
            mComputed = null;
        }
    }
    mCharsValid = hasReplacement;
    if (mCharsValid) {
        if (mChars == null || mChars.length < mLen) {
            mChars = ArrayUtils.newUnpaddedCharArray(mLen);
        }
        TextUtils.getChars(text, start, limit, mChars, 0);
        if (hasReplacement) {
            char[] chars = mChars;
            for (int i = start, inext; i < limit; i = inext) {
                inext = mReplacementSpanSpanSet.getNextTransition(i, limit);
                if (mReplacementSpanSpanSet.hasSpansIntersecting(i, inext) && (i - start >= ellipsisEnd || inext - start <= ellipsisStart)) {
                    chars[i - start] = '\ufffc';
                    for (int j = i - start + 1, e = inext - start; j < e; ++j) {
                        chars[j] = '\ufeff';
                    }
                }
            }
        }
    }
    mTabs = tabStops;
    mAddedWidthForJustify = 0;
    mIsJustifying = false;
    mEllipsisStart = ellipsisStart != ellipsisEnd ? ellipsisStart : 0;
    mEllipsisEnd = ellipsisStart != ellipsisEnd ? ellipsisEnd : 0;
}