public List<MandatoryStreamCombination> getAvailableMandatoryConcurrentStreamCombinations(){
    StreamCombinationTemplate[] chosenStreamCombinations = sConcurrentStreamCombinations;
    if (!isColorOutputSupported()) {
        Log.v(TAG, "Device is not backward compatible, depth streams are mandatory!");
        chosenStreamCombinations = sConcurrentDepthOnlyStreamCombinations;
    }
    Size sizeVGAp = new Size(640, 480);
    Size size720p = new Size(1280, 720);
    Size size1440p = new Size(1920, 1440);
    ArrayList<MandatoryStreamCombination> availableConcurrentStreamCombinations = new ArrayList<MandatoryStreamCombination>();
    availableConcurrentStreamCombinations.ensureCapacity(chosenStreamCombinations.length);
    for (StreamCombinationTemplate combTemplate : chosenStreamCombinations) {
        ArrayList<MandatoryStreamInformation> streamsInfo = new ArrayList<MandatoryStreamInformation>();
        streamsInfo.ensureCapacity(combTemplate.mStreamTemplates.length);
        for (StreamTemplate template : combTemplate.mStreamTemplates) {
            MandatoryStreamInformation streamInfo;
            List<Size> sizes = new ArrayList<Size>();
            Size formatSize = null;
            switch(template.mSizeThreshold) {
                case s1440p:
                    formatSize = size1440p;
                    break;
                case VGA:
                    formatSize = sizeVGAp;
                    break;
                default:
                    formatSize = size720p;
            }
            Size sizeChosen = getMinSize(formatSize, getMaxSize(mStreamConfigMap.getOutputSizes(template.mFormat)));
            sizes.add(sizeChosen);
            try {
                streamInfo = new MandatoryStreamInformation(sizes, template.mFormat);
            } catch (IllegalArgumentException e) {
                String cause = "No available sizes found for format: " + template.mFormat + " size threshold: " + template.mSizeThreshold + " combination: " + combTemplate.mDescription;
                throw new RuntimeException(cause, e);
            }
            streamsInfo.add(streamInfo);
        }
        MandatoryStreamCombination streamCombination;
        try {
            streamCombination = new MandatoryStreamCombination(streamsInfo, combTemplate.mDescription, false);
        } catch (IllegalArgumentException e) {
            String cause = "No stream information for mandatory combination: " + combTemplate.mDescription;
            throw new RuntimeException(cause, e);
        }
        availableConcurrentStreamCombinations.add(streamCombination);
    }
    return Collections.unmodifiableList(availableConcurrentStreamCombinations);
}