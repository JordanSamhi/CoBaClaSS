public void showFillUi(@NonNull AutofillId focusedId, @NonNull FillResponse response, @Nullable String filterText, @Nullable String servicePackageName, @NonNull ComponentName componentName, @NonNull CharSequence serviceLabel, @NonNull Drawable serviceIcon, @NonNull AutoFillUiCallback callback, int sessionId, boolean compatMode){
    if (sDebug) {
        final int size = filterText == null ? 0 : filterText.length();
        Slog.d(TAG, "showFillUi(): id=" + focusedId + ", filter=" + size + " chars");
    }
    final LogMaker log = Helper.newLogMaker(MetricsEvent.AUTOFILL_FILL_UI, componentName, servicePackageName, sessionId, compatMode).addTaggedData(MetricsEvent.FIELD_AUTOFILL_FILTERTEXT_LEN, filterText == null ? 0 : filterText.length()).addTaggedData(MetricsEvent.FIELD_AUTOFILL_NUM_DATASETS, response.getDatasets() == null ? 0 : response.getDatasets().size());
    final Runnable createFillUiRunnable = () -> {
        if (callback != mCallback) {
            return;
        }
        hideAllUiThread(callback);
        mFillUi = new FillUi(mContext, response, focusedId, filterText, mOverlayControl, serviceLabel, serviceIcon, mUiModeMgr.isNightMode(), new FillUi.Callback() {

            @Override
            public void onResponsePicked(FillResponse response) {
                log.setType(MetricsEvent.TYPE_DETAIL);
                hideFillUiUiThread(callback, true);
                if (mCallback != null) {
                    mCallback.authenticate(response.getRequestId(), AutofillManager.AUTHENTICATION_ID_DATASET_ID_UNDEFINED, response.getAuthentication(), response.getClientState(), false);
                }
            }

            @Override
            public void onDatasetPicked(Dataset dataset) {
                log.setType(MetricsEvent.TYPE_ACTION);
                hideFillUiUiThread(callback, true);
                if (mCallback != null) {
                    final int datasetIndex = response.getDatasets().indexOf(dataset);
                    mCallback.fill(response.getRequestId(), datasetIndex, dataset);
                }
            }

            @Override
            public void onCanceled() {
                log.setType(MetricsEvent.TYPE_DISMISS);
                hideFillUiUiThread(callback, true);
            }

            @Override
            public void onDestroy() {
                if (log.getType() == MetricsEvent.TYPE_UNKNOWN) {
                    log.setType(MetricsEvent.TYPE_CLOSE);
                }
                mMetricsLogger.write(log);
            }

            @Override
            public void requestShowFillUi(int width, int height, IAutofillWindowPresenter windowPresenter) {
                if (mCallback != null) {
                    mCallback.requestShowFillUi(focusedId, width, height, windowPresenter);
                }
            }

            @Override
            public void requestHideFillUi() {
                if (mCallback != null) {
                    mCallback.requestHideFillUi(focusedId);
                }
            }

            @Override
            public void startIntentSender(IntentSender intentSender) {
                if (mCallback != null) {
                    mCallback.startIntentSenderAndFinishSession(intentSender);
                }
            }

            @Override
            public void dispatchUnhandledKey(KeyEvent keyEvent) {
                if (mCallback != null) {
                    mCallback.dispatchUnhandledKey(focusedId, keyEvent);
                }
            }

            @Override
            public void cancelSession() {
                if (mCallback != null) {
                    mCallback.cancelSession();
                }
            }
        });
    };
    if (isSaveUiShowing()) {
        if (sDebug)
            Slog.d(TAG, "postpone fill UI request..");
        mCreateFillUiRunnable = createFillUiRunnable;
    } else {
        mHandler.post(createFillUiRunnable);
    }
}