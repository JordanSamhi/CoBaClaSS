public long getDelayForNextApn(boolean failFastEnabled){
    if (mWaitingApns == null || mWaitingApns.size() == 0) {
        log("Waiting APN list is null or empty.");
        return NO_RETRY;
    }
    if (mModemSuggestedDelay == NO_RETRY) {
        log("Modem suggested not retrying.");
        return NO_RETRY;
    }
    if (mModemSuggestedDelay != NO_SUGGESTED_RETRY_DELAY && mSameApnRetryCount < MAX_SAME_APN_RETRY) {
        log("Modem suggested retry in " + mModemSuggestedDelay + " ms.");
        return mModemSuggestedDelay;
    }
    int index = mCurrentApnIndex;
    while (true) {
        if (++index >= mWaitingApns.size())
            index = 0;
        if (!mWaitingApns.get(index).getPermanentFailed()) {
            break;
        }
        if (mWaitingApns.stream().allMatch(ApnSetting::getPermanentFailed)) {
            log("All APNs have permanently failed.");
            return NO_RETRY;
        }
    }
    long delay;
    if (index <= mCurrentApnIndex) {
        if (!mRetryForever && mRetryCount + 1 > mMaxRetryCount) {
            log("Reached maximum retry count " + mMaxRetryCount + ".");
            return NO_RETRY;
        }
        delay = getRetryTimer();
        ++mRetryCount;
    } else {
        delay = mInterApnDelay;
    }
    if (failFastEnabled && delay > mFailFastInterApnDelay) {
        delay = mFailFastInterApnDelay;
    }
    return delay;
}