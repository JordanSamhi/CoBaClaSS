public void backupNow(){
    mContext.enforceCallingOrSelfPermission(android.Manifest.permission.BACKUP, "backupNow");
    long oldId = Binder.clearCallingIdentity();
    try {
        final PowerSaveState result = mPowerManager.getPowerSaveState(ServiceType.KEYVALUE_BACKUP);
        if (result.batterySaverEnabled) {
            if (DEBUG) {
                Slog.v(TAG, addUserIdToLogMessage(mUserId, "Not running backup while in battery save mode"));
            }
            KeyValueBackupJob.schedule(mUserId, mContext, mConstants);
        } else {
            if (DEBUG) {
                Slog.v(TAG, addUserIdToLogMessage(mUserId, "Scheduling immediate backup pass"));
            }
            synchronized (getQueueLock()) {
                if (getPendingInits().size() > 0) {
                    if (MORE_DEBUG) {
                        Slog.v(TAG, addUserIdToLogMessage(mUserId, "Init pending at scheduled backup"));
                    }
                    try {
                        getAlarmManager().cancel(mRunInitIntent);
                        mRunInitIntent.send();
                    } catch (PendingIntent.CanceledException ce) {
                        Slog.w(TAG, addUserIdToLogMessage(mUserId, "Run init intent cancelled"));
                    }
                    return;
                }
            }
            if (!isEnabled() || !isSetupComplete()) {
                Slog.w(TAG, addUserIdToLogMessage(mUserId, "Backup pass but enabled=" + isEnabled() + " setupComplete=" + isSetupComplete()));
                return;
            }
            Message message = mBackupHandler.obtainMessage(MSG_RUN_BACKUP);
            mBackupHandler.sendMessage(message);
            KeyValueBackupJob.cancel(mUserId, mContext);
        }
    } finally {
        Binder.restoreCallingIdentity(oldId);
    }
}