public static byte[] decrypt(@Nullable PrivateKey ourPrivateKey, @Nullable byte[] sharedSecret, @Nullable byte[] header, byte[] encryptedPayload) throws NoSuchAlgorithmException, InvalidKeyException, AEADBadTagException{
    sharedSecret = emptyByteArrayIfNull(sharedSecret);
    if (ourPrivateKey == null && sharedSecret.length == 0) {
        throw new IllegalArgumentException("Both the private key and shared secret are empty");
    }
    header = emptyByteArrayIfNull(header);
    if (encryptedPayload == null) {
        throw new NullPointerException("Encrypted payload must not be null.");
    }
    ByteBuffer ciphertextBuffer = ByteBuffer.wrap(encryptedPayload);
    byte[] version = readEncryptedPayload(ciphertextBuffer, VERSION.length);
    if (!Arrays.equals(version, VERSION)) {
        throw new AEADBadTagException("The payload was not encrypted by SecureBox v2");
    }
    byte[] senderPublicKeyBytes;
    byte[] dhSecret;
    byte[] hkdfInfo;
    if (ourPrivateKey == null) {
        dhSecret = EMPTY_BYTE_ARRAY;
        hkdfInfo = HKDF_INFO_WITHOUT_PUBLIC_KEY;
    } else {
        senderPublicKeyBytes = readEncryptedPayload(ciphertextBuffer, EC_PUBLIC_KEY_LEN_BYTES);
        dhSecret = dhComputeSecret(ourPrivateKey, decodePublicKey(senderPublicKeyBytes));
        hkdfInfo = HKDF_INFO_WITH_PUBLIC_KEY;
    }
    byte[] randNonce = readEncryptedPayload(ciphertextBuffer, GCM_NONCE_LEN_BYTES);
    byte[] ciphertext = readEncryptedPayload(ciphertextBuffer, ciphertextBuffer.remaining());
    byte[] keyingMaterial = concat(dhSecret, sharedSecret);
    SecretKey decryptionKey = hkdfDeriveKey(keyingMaterial, HKDF_SALT, hkdfInfo);
    return aesGcmDecrypt(decryptionKey, randNonce, ciphertext, header);
}