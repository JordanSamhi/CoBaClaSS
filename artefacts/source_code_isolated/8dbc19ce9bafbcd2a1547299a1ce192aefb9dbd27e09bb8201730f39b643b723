public void obtainPositionMetadata(PositionMetadata metadata, int position){
    if (metadata.listPosition == position) {
        return;
    }
    int listPosition = 0;
    int cursorPosition = 0;
    int firstGroupToCheck = 0;
    if (mLastCachedListPosition != -1) {
        if (position <= mLastCachedListPosition) {
            int index = mPositionCache.indexOfKey(position);
            if (index < 0) {
                index = ~index - 1;
                if (index >= mPositionCache.size()) {
                    index--;
                }
            }
            if (index >= 0) {
                listPosition = mPositionCache.keyAt(index);
                firstGroupToCheck = mPositionCache.valueAt(index);
                long descriptor = mGroupMetadata[firstGroupToCheck];
                cursorPosition = (int) (descriptor & GROUP_OFFSET_MASK);
            }
        } else {
            firstGroupToCheck = mLastCachedGroup;
            listPosition = mLastCachedListPosition;
            cursorPosition = mLastCachedCursorPosition;
        }
    }
    for (int i = firstGroupToCheck; i < mGroupCount; i++) {
        long group = mGroupMetadata[i];
        int offset = (int) (group & GROUP_OFFSET_MASK);
        listPosition += (offset - cursorPosition);
        cursorPosition = offset;
        if (i > mLastCachedGroup) {
            mPositionCache.append(listPosition, i);
            mLastCachedListPosition = listPosition;
            mLastCachedCursorPosition = cursorPosition;
            mLastCachedGroup = i;
        }
        if (position < listPosition) {
            metadata.itemType = ITEM_TYPE_STANDALONE;
            metadata.cursorPosition = cursorPosition - (listPosition - position);
            return;
        }
        boolean expanded = (group & EXPANDED_GROUP_MASK) != 0;
        int size = (int) ((group & GROUP_SIZE_MASK) >> 32);
        if (position == listPosition) {
            metadata.itemType = ITEM_TYPE_GROUP_HEADER;
            metadata.groupPosition = i;
            metadata.isExpanded = expanded;
            metadata.childCount = size;
            metadata.cursorPosition = offset;
            return;
        }
        if (expanded) {
            if (position < listPosition + size + 1) {
                metadata.itemType = ITEM_TYPE_IN_GROUP;
                metadata.cursorPosition = cursorPosition + (position - listPosition) - 1;
                return;
            }
            listPosition += size + 1;
        } else {
            listPosition++;
        }
        cursorPosition += size;
    }
    metadata.itemType = ITEM_TYPE_STANDALONE;
    metadata.cursorPosition = cursorPosition + (position - listPosition);
}