public void dismissChild(final View animView, float velocity, final Runnable endAction, long delay, boolean useAccelerateInterpolator, long fixedDuration, boolean isDismissAll){
    final boolean canBeDismissed = mCallback.canChildBeDismissed(animView);
    float newPos;
    boolean isLayoutRtl = animView.getLayoutDirection() == View.LAYOUT_DIRECTION_RTL;
    boolean animateUpForMenu = velocity == 0 && (getTranslation(animView) == 0 || isDismissAll) && mSwipeDirection == Y;
    boolean animateLeftForRtl = velocity == 0 && (getTranslation(animView) == 0 || isDismissAll) && isLayoutRtl;
    boolean animateLeft = (Math.abs(velocity) > getEscapeVelocity() && velocity < 0) || (getTranslation(animView) < 0 && !isDismissAll);
    if (animateLeft || animateLeftForRtl || animateUpForMenu) {
        newPos = -getSize(animView);
    } else {
        newPos = getSize(animView);
    }
    long duration;
    if (fixedDuration == 0) {
        duration = MAX_ESCAPE_ANIMATION_DURATION;
        if (velocity != 0) {
            duration = Math.min(duration, (int) (Math.abs(newPos - getTranslation(animView)) * 1000f / Math.abs(velocity)));
        } else {
            duration = DEFAULT_ESCAPE_ANIMATION_DURATION;
        }
    } else {
        duration = fixedDuration;
    }
    if (!mDisableHwLayers) {
        animView.setLayerType(View.LAYER_TYPE_HARDWARE, null);
    }
    AnimatorUpdateListener updateListener = new AnimatorUpdateListener() {

        @Override
        public void onAnimationUpdate(ValueAnimator animation) {
            onTranslationUpdate(animView, (float) animation.getAnimatedValue(), canBeDismissed);
        }
    };
    Animator anim = getViewTranslationAnimator(animView, newPos, updateListener);
    if (anim == null) {
        return;
    }
    if (useAccelerateInterpolator) {
        anim.setInterpolator(Interpolators.FAST_OUT_LINEAR_IN);
        anim.setDuration(duration);
    } else {
        mFlingAnimationUtils.applyDismissing(anim, getTranslation(animView), newPos, velocity, getSize(animView));
    }
    if (delay > 0) {
        anim.setStartDelay(delay);
    }
    anim.addListener(new AnimatorListenerAdapter() {

        private boolean mCancelled;

        @Override
        public void onAnimationCancel(Animator animation) {
            mCancelled = true;
        }

        @Override
        public void onAnimationEnd(Animator animation) {
            updateSwipeProgressFromOffset(animView, canBeDismissed);
            mDismissPendingMap.remove(animView);
            boolean wasRemoved = false;
            if (animView instanceof ExpandableNotificationRow) {
                ExpandableNotificationRow row = (ExpandableNotificationRow) animView;
                wasRemoved = row.isRemoved();
            }
            if (!mCancelled || wasRemoved) {
                mCallback.onChildDismissed(animView);
            }
            if (endAction != null) {
                endAction.run();
            }
            if (!mDisableHwLayers) {
                animView.setLayerType(View.LAYER_TYPE_NONE, null);
            }
        }
    });
    prepareDismissAnimation(animView, anim);
    mDismissPendingMap.put(animView, anim);
    anim.start();
}