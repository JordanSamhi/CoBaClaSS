public Entry getValues(long start, long end, long now, Entry recycle){
    final Entry entry = recycle != null ? recycle : new Entry();
    entry.bucketDuration = end - start;
    entry.bucketStart = start;
    entry.activeTime = activeTime != null ? 0 : UNKNOWN;
    entry.rxBytes = rxBytes != null ? 0 : UNKNOWN;
    entry.rxPackets = rxPackets != null ? 0 : UNKNOWN;
    entry.txBytes = txBytes != null ? 0 : UNKNOWN;
    entry.txPackets = txPackets != null ? 0 : UNKNOWN;
    entry.operations = operations != null ? 0 : UNKNOWN;
    final int startIndex = getIndexAfter(end);
    for (int i = startIndex; i >= 0; i--) {
        final long curStart = bucketStart[i];
        long curEnd = curStart + bucketDuration;
        if (curEnd <= start)
            break;
        if (curStart >= end)
            continue;
        if (curEnd > now)
            curEnd = now;
        final long bucketSpan = curEnd - curStart;
        if (bucketSpan <= 0)
            continue;
        final long overlapEnd = curEnd < end ? curEnd : end;
        final long overlapStart = curStart > start ? curStart : start;
        final long overlap = overlapEnd - overlapStart;
        if (overlap <= 0)
            continue;
        if (activeTime != null)
            entry.activeTime += activeTime[i] * overlap / bucketSpan;
        if (rxBytes != null)
            entry.rxBytes += rxBytes[i] * overlap / bucketSpan;
        if (rxPackets != null)
            entry.rxPackets += rxPackets[i] * overlap / bucketSpan;
        if (txBytes != null)
            entry.txBytes += txBytes[i] * overlap / bucketSpan;
        if (txPackets != null)
            entry.txPackets += txPackets[i] * overlap / bucketSpan;
        if (operations != null)
            entry.operations += operations[i] * overlap / bucketSpan;
    }
    return entry;
}