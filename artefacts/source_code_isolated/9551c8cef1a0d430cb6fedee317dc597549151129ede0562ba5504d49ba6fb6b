public void maybeStartTrackingJobLocked(JobStatus job, JobStatus lastJob){
    if (job.hasTimingDelayConstraint() || job.hasDeadlineConstraint()) {
        maybeStopTrackingJobLocked(job, null, false);
        final long nowElapsedMillis = sElapsedRealtimeClock.millis();
        if (job.hasDeadlineConstraint() && evaluateDeadlineConstraint(job, nowElapsedMillis)) {
            return;
        } else if (job.hasTimingDelayConstraint() && evaluateTimingDelayConstraint(job, nowElapsedMillis)) {
            if (!job.hasDeadlineConstraint()) {
                return;
            }
        }
        boolean isInsert = false;
        ListIterator<JobStatus> it = mTrackedJobs.listIterator(mTrackedJobs.size());
        while (it.hasPrevious()) {
            JobStatus ts = it.previous();
            if (ts.getLatestRunTimeElapsed() < job.getLatestRunTimeElapsed()) {
                isInsert = true;
                break;
            }
        }
        if (isInsert) {
            it.next();
        }
        it.add(job);
        job.setTrackingController(JobStatus.TRACKING_TIME);
        WorkSource ws = deriveWorkSource(job.getSourceUid(), job.getSourcePackageName());
        if (job.hasTimingDelayConstraint() && wouldBeReadyWithConstraintLocked(job, JobStatus.CONSTRAINT_TIMING_DELAY)) {
            maybeUpdateDelayAlarmLocked(job.getEarliestRunTime(), ws);
        }
        if (job.hasDeadlineConstraint() && wouldBeReadyWithConstraintLocked(job, JobStatus.CONSTRAINT_DEADLINE)) {
            maybeUpdateDeadlineAlarmLocked(job.getLatestRunTimeElapsed(), ws);
        }
    }
}