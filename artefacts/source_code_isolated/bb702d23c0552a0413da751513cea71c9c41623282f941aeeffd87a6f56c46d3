public static void read(XmlPullParser parser, IntervalStats statsOut) throws XmlPullParserException, IOException{
    statsOut.packageStats.clear();
    statsOut.configurations.clear();
    statsOut.activeConfiguration = null;
    statsOut.events.clear();
    statsOut.endTime = statsOut.beginTime + XmlUtils.readLongAttribute(parser, END_TIME_ATTR);
    try {
        statsOut.majorVersion = XmlUtils.readIntAttribute(parser, MAJOR_VERSION_ATTR);
    } catch (IOException e) {
        Log.i(TAG, "Failed to parse majorVersion");
    }
    try {
        statsOut.minorVersion = XmlUtils.readIntAttribute(parser, MINOR_VERSION_ATTR);
    } catch (IOException e) {
        Log.i(TAG, "Failed to parse minorVersion");
    }
    int eventCode;
    int outerDepth = parser.getDepth();
    while ((eventCode = parser.next()) != XmlPullParser.END_DOCUMENT && (eventCode != XmlPullParser.END_TAG || parser.getDepth() > outerDepth)) {
        if (eventCode != XmlPullParser.START_TAG) {
            continue;
        }
        final String tag = parser.getName();
        switch(tag) {
            case INTERACTIVE_TAG:
                loadCountAndTime(parser, statsOut.interactiveTracker);
                break;
            case NON_INTERACTIVE_TAG:
                loadCountAndTime(parser, statsOut.nonInteractiveTracker);
                break;
            case KEYGUARD_SHOWN_TAG:
                loadCountAndTime(parser, statsOut.keyguardShownTracker);
                break;
            case KEYGUARD_HIDDEN_TAG:
                loadCountAndTime(parser, statsOut.keyguardHiddenTracker);
                break;
            case PACKAGE_TAG:
                loadUsageStats(parser, statsOut);
                break;
            case CONFIG_TAG:
                loadConfigStats(parser, statsOut);
                break;
            case EVENT_TAG:
                loadEvent(parser, statsOut);
                break;
        }
    }
}