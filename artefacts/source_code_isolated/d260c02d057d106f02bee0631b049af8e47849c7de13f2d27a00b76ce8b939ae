public void computeChangedWindows(boolean forceSend){
    if (DEBUG) {
        Slog.i(LOG_TAG, "computeChangedWindows()");
    }
    List<WindowInfo> windows = new ArrayList<>();
    final int topFocusedDisplayId;
    IBinder topFocusedWindowToken = null;
    synchronized (mService.mGlobalLock) {
        final WindowState topFocusedWindowState = getTopFocusWindow();
        if (topFocusedWindowState == null)
            return;
        final DisplayContent dc = mService.mRoot.getDisplayContent(mDisplayId);
        if (dc == null) {
            return;
        }
        final Display display = dc.getDisplay();
        display.getRealSize(mTempPoint);
        final int screenWidth = mTempPoint.x;
        final int screenHeight = mTempPoint.y;
        Region unaccountedSpace = mTempRegion;
        unaccountedSpace.set(0, 0, screenWidth, screenHeight);
        final SparseArray<WindowState> visibleWindows = mTempWindowStates;
        populateVisibleWindowsOnScreenLocked(visibleWindows);
        Set<IBinder> addedWindows = mTempBinderSet;
        addedWindows.clear();
        boolean focusedWindowAdded = false;
        final int visibleWindowCount = visibleWindows.size();
        HashSet<Integer> skipRemainingWindowsForTasks = new HashSet<>();
        for (int i = visibleWindowCount - 1; i >= 0; i--) {
            final WindowState windowState = visibleWindows.valueAt(i);
            final Region regionInScreen = new Region();
            computeWindowRegionInScreen(windowState, regionInScreen);
            if (windowMattersToAccessibility(windowState, regionInScreen, unaccountedSpace, skipRemainingWindowsForTasks)) {
                addPopulatedWindowInfo(windowState, regionInScreen, windows, addedWindows);
                updateUnaccountedSpace(windowState, regionInScreen, unaccountedSpace, skipRemainingWindowsForTasks);
                focusedWindowAdded |= windowState.isFocused();
            } else if (isUntouchableNavigationBar(windowState, mTempRegion1)) {
                unaccountedSpace.op(getNavBarInsets(dc), unaccountedSpace, Region.Op.REVERSE_DIFFERENCE);
            }
            if (unaccountedSpace.isEmpty() && focusedWindowAdded) {
                break;
            }
        }
        for (int i = dc.mShellRoots.size() - 1; i >= 0; --i) {
            final WindowInfo info = dc.mShellRoots.valueAt(i).getWindowInfo();
            if (info == null) {
                continue;
            }
            info.layer = addedWindows.size();
            windows.add(info);
            addedWindows.add(info.token);
        }
        final int windowCount = windows.size();
        for (int i = 0; i < windowCount; i++) {
            WindowInfo window = windows.get(i);
            if (!addedWindows.contains(window.parentToken)) {
                window.parentToken = null;
            }
            if (window.childTokens != null) {
                final int childTokenCount = window.childTokens.size();
                for (int j = childTokenCount - 1; j >= 0; j--) {
                    if (!addedWindows.contains(window.childTokens.get(j))) {
                        window.childTokens.remove(j);
                    }
                }
            }
        }
        visibleWindows.clear();
        addedWindows.clear();
        topFocusedDisplayId = mService.mRoot.getTopFocusedDisplayContent().getDisplayId();
        topFocusedWindowToken = topFocusedWindowState.mClient.asBinder();
    }
    mCallback.onWindowsForAccessibilityChanged(forceSend, topFocusedDisplayId, topFocusedWindowToken, windows);
    clearAndRecycleWindows(windows);
}