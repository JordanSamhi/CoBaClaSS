public void decryptFile(File inputFile, DecryptedChunkOutput decryptedChunkOutput) throws IOException, EncryptedRestoreException, IllegalBlockSizeException, BadPaddingException, InvalidAlgorithmParameterException, InvalidKeyException, ShortBufferException, NoSuchAlgorithmException{
    RandomAccessFile input = new RandomAccessFile(inputFile, READ_MODE);
    long metadataOffset = getChunksMetadataOffset(input);
    ChunksMetadataProto.ChunksMetadata chunksMetadata = getChunksMetadata(input, metadataOffset);
    ChunkOrdering chunkOrdering = decryptChunkOrdering(chunksMetadata);
    if (chunksMetadata.chunkOrderingType == ChunksMetadataProto.CHUNK_ORDERING_TYPE_UNSPECIFIED || chunksMetadata.chunkOrderingType == ChunksMetadataProto.EXPLICIT_STARTS) {
        Slog.d(TAG, "Using explicit starts");
        decryptFileWithExplicitStarts(input, decryptedChunkOutput, chunkOrdering, metadataOffset);
    } else if (chunksMetadata.chunkOrderingType == ChunksMetadataProto.INLINE_LENGTHS) {
        Slog.d(TAG, "Using inline lengths");
        decryptFileWithInlineLengths(input, decryptedChunkOutput, metadataOffset);
    } else {
        throw new UnsupportedEncryptedFileException("Unknown chunk ordering type:" + chunksMetadata.chunkOrderingType);
    }
    if (!Arrays.equals(decryptedChunkOutput.getDigest(), chunkOrdering.checksum)) {
        throw new MessageDigestMismatchException("Checksums did not match");
    }
}