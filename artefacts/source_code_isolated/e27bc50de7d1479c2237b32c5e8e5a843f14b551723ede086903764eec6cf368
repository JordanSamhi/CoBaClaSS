public static SubmitPdu getDeliverPdu(String scAddress, String originatingAddress, String message, long date){
    if (originatingAddress == null || message == null) {
        return null;
    }
    TextEncodingDetails ted = calculateLength(message, false);
    int encoding = ted.codeUnitSize;
    int languageTable = ted.languageTable;
    int languageShiftTable = ted.languageShiftTable;
    byte[] header = null;
    if (encoding == ENCODING_7BIT && (languageTable != 0 || languageShiftTable != 0)) {
        SmsHeader smsHeader = new SmsHeader();
        smsHeader.languageTable = languageTable;
        smsHeader.languageShiftTable = languageShiftTable;
        header = SmsHeader.toByteArray(smsHeader);
    }
    SubmitPdu ret = new SubmitPdu();
    ByteArrayOutputStream bo = new ByteArrayOutputStream(MAX_USER_DATA_BYTES + 40);
    if (scAddress == null) {
        ret.encodedScAddress = null;
    } else {
        ret.encodedScAddress = PhoneNumberUtils.networkPortionToCalledPartyBCDWithLength(scAddress);
    }
    bo.write(0);
    byte[] oaBytes;
    oaBytes = PhoneNumberUtils.networkPortionToCalledPartyBCD(originatingAddress);
    if (oaBytes == null)
        return null;
    bo.write((oaBytes.length - 1) * 2 - ((oaBytes[oaBytes.length - 1] & 0xf0) == 0xf0 ? 1 : 0));
    bo.write(oaBytes, 0, oaBytes.length);
    bo.write(0);
    byte[] userData;
    try {
        if (encoding == ENCODING_7BIT) {
            userData = GsmAlphabet.stringToGsm7BitPackedWithHeader(message, header, languageTable, languageShiftTable);
        } else {
            try {
                userData = encodeUCS2(message, header);
            } catch (UnsupportedEncodingException uex) {
                Rlog.e(LOG_TAG, "Implausible UnsupportedEncodingException ", uex);
                return null;
            }
        }
    } catch (EncodeException ex) {
        if (ex.getError() == EncodeException.ERROR_EXCEED_SIZE) {
            Rlog.e(LOG_TAG, "Exceed size limitation EncodeException", ex);
            return null;
        } else {
            try {
                userData = encodeUCS2(message, header);
                encoding = ENCODING_16BIT;
            } catch (EncodeException ex1) {
                Rlog.e(LOG_TAG, "Exceed size limitation EncodeException", ex1);
                return null;
            } catch (UnsupportedEncodingException uex) {
                Rlog.e(LOG_TAG, "Implausible UnsupportedEncodingException ", uex);
                return null;
            }
        }
    }
    if (encoding == ENCODING_7BIT) {
        if ((0xff & userData[0]) > MAX_USER_DATA_SEPTETS) {
            Rlog.e(LOG_TAG, "Message too long (" + (0xff & userData[0]) + " septets)");
            return null;
        }
        bo.write(0x00);
    } else {
        if ((0xff & userData[0]) > MAX_USER_DATA_BYTES) {
            Rlog.e(LOG_TAG, "Message too long (" + (0xff & userData[0]) + " bytes)");
            return null;
        }
        bo.write(0x08);
    }
    byte[] scts = new byte[7];
    ZonedDateTime zoneDateTime = Instant.ofEpochMilli(date).atZone(ZoneId.systemDefault());
    LocalDateTime localDateTime = zoneDateTime.toLocalDateTime();
    int timezoneOffset = zoneDateTime.getOffset().getTotalSeconds() / 60 / 15;
    boolean negativeOffset = timezoneOffset < 0;
    if (negativeOffset) {
        timezoneOffset = -timezoneOffset;
    }
    int year = localDateTime.getYear();
    int month = localDateTime.getMonthValue();
    int day = localDateTime.getDayOfMonth();
    int hour = localDateTime.getHour();
    int minute = localDateTime.getMinute();
    int second = localDateTime.getSecond();
    year = year > 2000 ? year - 2000 : year - 1900;
    scts[0] = (byte) ((((year % 10) & 0x0F) << 4) | ((year / 10) & 0x0F));
    scts[1] = (byte) ((((month % 10) & 0x0F) << 4) | ((month / 10) & 0x0F));
    scts[2] = (byte) ((((day % 10) & 0x0F) << 4) | ((day / 10) & 0x0F));
    scts[3] = (byte) ((((hour % 10) & 0x0F) << 4) | ((hour / 10) & 0x0F));
    scts[4] = (byte) ((((minute % 10) & 0x0F) << 4) | ((minute / 10) & 0x0F));
    scts[5] = (byte) ((((second % 10) & 0x0F) << 4) | ((second / 10) & 0x0F));
    scts[6] = (byte) ((((timezoneOffset % 10) & 0x0F) << 4) | ((timezoneOffset / 10) & 0x0F));
    if (negativeOffset) {
        scts[0] |= 0x08;
    }
    bo.write(scts, 0, scts.length);
    bo.write(userData, 0, userData.length);
    ret.encodedMessage = bo.toByteArray();
    return ret;
}