public void adbRestore(ParcelFileDescriptor fd){
    mContext.enforceCallingPermission(android.Manifest.permission.BACKUP, "adbRestore");
    final int callingUserHandle = UserHandle.getCallingUserId();
    if (callingUserHandle != UserHandle.USER_SYSTEM) {
        throw new IllegalStateException("Restore supported only for the device owner");
    }
    long oldId = Binder.clearCallingIdentity();
    try {
        if (!mSetupComplete) {
            Slog.i(TAG, addUserIdToLogMessage(mUserId, "Full restore not permitted before setup"));
            return;
        }
        Slog.i(TAG, addUserIdToLogMessage(mUserId, "Beginning restore..."));
        AdbRestoreParams params = new AdbRestoreParams(fd);
        final int token = generateRandomIntegerToken();
        synchronized (mAdbBackupRestoreConfirmations) {
            mAdbBackupRestoreConfirmations.put(token, params);
        }
        if (DEBUG) {
            Slog.d(TAG, addUserIdToLogMessage(mUserId, "Starting restore confirmation UI, token=" + token));
        }
        if (!startConfirmationUi(token, FullBackup.FULL_RESTORE_INTENT_ACTION)) {
            Slog.e(TAG, addUserIdToLogMessage(mUserId, "Unable to launch restore confirmation"));
            mAdbBackupRestoreConfirmations.delete(token);
            return;
        }
        mPowerManager.userActivity(SystemClock.uptimeMillis(), PowerManager.USER_ACTIVITY_EVENT_OTHER, 0);
        startConfirmationTimeout(token, params);
        if (DEBUG) {
            Slog.d(TAG, addUserIdToLogMessage(mUserId, "Waiting for restore completion..."));
        }
        waitForCompletion(params);
    } finally {
        try {
            fd.close();
        } catch (IOException e) {
            Slog.w(TAG, addUserIdToLogMessage(mUserId, "Error trying to close fd after adb restore: " + e));
        }
        Binder.restoreCallingIdentity(oldId);
        Slog.i(TAG, addUserIdToLogMessage(mUserId, "adb restore processing complete."));
    }
}