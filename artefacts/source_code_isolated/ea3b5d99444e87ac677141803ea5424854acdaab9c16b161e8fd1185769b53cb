public boolean preprocessCdmaFdeaWap(){
    try {
        BitwiseInputStream inStream = new BitwiseInputStream(mUserData);
        if (inStream.read(8) != 0x00) {
            Rlog.e(LOG_TAG, "Invalid FDEA WDP Header Message Identifier SUBPARAMETER_ID");
            return false;
        }
        if (inStream.read(8) != 0x03) {
            Rlog.e(LOG_TAG, "Invalid FDEA WDP Header Message Identifier SUBPARAM_LEN");
            return false;
        }
        mBearerData.messageType = inStream.read(4);
        int msgId = inStream.read(8) << 8;
        msgId |= inStream.read(8);
        mBearerData.messageId = msgId;
        mMessageRef = msgId;
        mBearerData.hasUserDataHeader = (inStream.read(1) == 1);
        if (mBearerData.hasUserDataHeader) {
            Rlog.e(LOG_TAG, "Invalid FDEA WDP Header Message Identifier HEADER_IND");
            return false;
        }
        inStream.skip(3);
        if (inStream.read(8) != 0x01) {
            Rlog.e(LOG_TAG, "Invalid FDEA WDP Header User Data SUBPARAMETER_ID");
            return false;
        }
        int userDataLen = inStream.read(8) * 8;
        mBearerData.userData.msgEncoding = inStream.read(5);
        int consumedBits = 5;
        if (mBearerData.userData.msgEncoding != UserData.ENCODING_OCTET) {
            Rlog.e(LOG_TAG, "Invalid FDEA WDP Header User Data MSG_ENCODING");
            return false;
        }
        mBearerData.userData.numFields = inStream.read(8);
        consumedBits += 8;
        int remainingBits = userDataLen - consumedBits;
        int dataBits = mBearerData.userData.numFields * 8;
        dataBits = dataBits < remainingBits ? dataBits : remainingBits;
        mBearerData.userData.payload = inStream.readByteArray(dataBits);
        mUserData = mBearerData.userData.payload;
        return true;
    } catch (BitwiseInputStream.AccessException ex) {
        Rlog.e(LOG_TAG, "Fail to preprocess FDEA WAP: " + ex);
    }
    return false;
}