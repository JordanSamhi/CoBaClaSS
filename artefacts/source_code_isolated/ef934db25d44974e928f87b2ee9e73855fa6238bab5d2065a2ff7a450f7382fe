public int[] getRecoverySecretTypes(int userId, int uid){
    SQLiteDatabase db = mKeyStoreDbHelper.getReadableDatabase();
    String[] projection = { RecoveryServiceMetadataEntry._ID, RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID, RecoveryServiceMetadataEntry.COLUMN_NAME_UID, RecoveryServiceMetadataEntry.COLUMN_NAME_SECRET_TYPES };
    String selection = RecoveryServiceMetadataEntry.COLUMN_NAME_USER_ID + " = ? AND " + RecoveryServiceMetadataEntry.COLUMN_NAME_UID + " = ?";
    String[] selectionArguments = { Integer.toString(userId), Integer.toString(uid) };
    try (Cursor cursor = db.query(RecoveryServiceMetadataEntry.TABLE_NAME, projection, selection, selectionArguments, null, null, null)) {
        int count = cursor.getCount();
        if (count == 0) {
            return new int[] {};
        }
        if (count > 1) {
            Log.wtf(TAG, String.format(Locale.US, "%d deviceId entries found for userId=%d uid=%d. " + "Should only ever be 0 or 1.", count, userId, uid));
            return new int[] {};
        }
        cursor.moveToFirst();
        int idx = cursor.getColumnIndexOrThrow(RecoveryServiceMetadataEntry.COLUMN_NAME_SECRET_TYPES);
        if (cursor.isNull(idx)) {
            return new int[] {};
        }
        String csv = cursor.getString(idx);
        if (TextUtils.isEmpty(csv)) {
            return new int[] {};
        }
        String[] types = csv.split(",");
        int[] result = new int[types.length];
        for (int i = 0; i < types.length; i++) {
            try {
                result[i] = Integer.parseInt(types[i]);
            } catch (NumberFormatException e) {
                Log.wtf(TAG, "String format error " + e);
            }
        }
        return result;
    }
}