public int compareTo(WindowContainer other){
    if (this == other) {
        return 0;
    }
    if (mParent != null && mParent == other.mParent) {
        final WindowList<WindowContainer> list = mParent.mChildren;
        return list.indexOf(this) > list.indexOf(other) ? 1 : -1;
    }
    final LinkedList<WindowContainer> thisParentChain = mTmpChain1;
    final LinkedList<WindowContainer> otherParentChain = mTmpChain2;
    try {
        getParents(thisParentChain);
        other.getParents(otherParentChain);
        WindowContainer commonAncestor = null;
        WindowContainer thisTop = thisParentChain.peekLast();
        WindowContainer otherTop = otherParentChain.peekLast();
        while (thisTop != null && otherTop != null && thisTop == otherTop) {
            commonAncestor = thisParentChain.removeLast();
            otherParentChain.removeLast();
            thisTop = thisParentChain.peekLast();
            otherTop = otherParentChain.peekLast();
        }
        if (commonAncestor == null) {
            throw new IllegalArgumentException("No in the same hierarchy this=" + thisParentChain + " other=" + otherParentChain);
        }
        if (commonAncestor == this) {
            return -1;
        } else if (commonAncestor == other) {
            return 1;
        }
        final WindowList<WindowContainer> list = commonAncestor.mChildren;
        return list.indexOf(thisParentChain.peekLast()) > list.indexOf(otherParentChain.peekLast()) ? 1 : -1;
    } finally {
        mTmpChain1.clear();
        mTmpChain2.clear();
    }
}