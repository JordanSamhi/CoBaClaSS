public void quantize(int[] pixels, int maxColors, Palette.Filter[] filters){
    final float[] hsl = { 0, 0, 0 };
    final float[][] hslPixels = new float[pixels.length][3];
    for (int i = 0; i < pixels.length; i++) {
        ColorUtils.colorToHSL(pixels[i], hsl);
        hslPixels[i][0] = hsl[0] / 360f;
        hslPixels[i][1] = hsl[1];
        hslPixels[i][2] = hsl[2];
    }
    final List<KMeans.Mean> optimalMeans = getOptimalKMeans(maxColors, hslPixels);
    for (int i = 0; i < optimalMeans.size(); i++) {
        KMeans.Mean current = optimalMeans.get(i);
        float[] currentCentroid = current.getCentroid();
        for (int j = i + 1; j < optimalMeans.size(); j++) {
            KMeans.Mean compareTo = optimalMeans.get(j);
            float[] compareToCentroid = compareTo.getCentroid();
            float sqDistance = KMeans.sqDistance(currentCentroid, compareToCentroid);
            if (sqDistance < mMinClusterSqDistance) {
                optimalMeans.remove(compareTo);
                current.getItems().addAll(compareTo.getItems());
                for (int k = 0; k < currentCentroid.length; k++) {
                    currentCentroid[k] += (compareToCentroid[k] - currentCentroid[k]) / 2.0;
                }
                j--;
            }
        }
    }
    mQuantizedColors = new ArrayList<>();
    for (KMeans.Mean mean : optimalMeans) {
        if (mean.getItems().size() == 0) {
            continue;
        }
        float[] centroid = mean.getCentroid();
        mQuantizedColors.add(new Palette.Swatch(new float[] { centroid[0] * 360f, centroid[1], centroid[2] }, mean.getItems().size()));
    }
}