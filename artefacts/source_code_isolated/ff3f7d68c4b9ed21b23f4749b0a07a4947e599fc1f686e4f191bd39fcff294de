public void processCode() throws CallStateException{
    try {
        if (isShortCode()) {
            Rlog.d(LOG_TAG, "processCode: isShortCode");
            sendUssd(mDialingNumber);
        } else if (mDialingNumber != null) {
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        } else if (mSc != null && mSc.equals(SC_CLIP)) {
            Rlog.d(LOG_TAG, "processCode: is CLIP");
            if (isInterrogate()) {
                mPhone.mCi.queryCLIP(obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_CLIR)) {
            Rlog.d(LOG_TAG, "processCode: is CLIR");
            if (isActivate() && !mPhone.isClirActivationAndDeactivationPrevented()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_INVOCATION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isDeactivate() && !mPhone.isClirActivationAndDeactivationPrevented()) {
                mPhone.mCi.setCLIR(CommandsInterface.CLIR_SUPPRESSION, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.getCLIR(obtainMessage(EVENT_GET_CLIR_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isServiceCodeCallForwarding(mSc)) {
            Rlog.d(LOG_TAG, "processCode: is CF");
            String dialingNumber = mSia;
            int serviceClass = siToServiceClass(mSib);
            int reason = scToCallForwardReason(mSc);
            int time = siToTime(mSic);
            if (isInterrogate()) {
                mPhone.mCi.queryCallForwardStatus(reason, serviceClass, dialingNumber, obtainMessage(EVENT_QUERY_CF_COMPLETE, this));
            } else {
                int cfAction;
                if (isActivate()) {
                    if (isEmptyOrNull(dialingNumber)) {
                        cfAction = CommandsInterface.CF_ACTION_ENABLE;
                        mIsCallFwdReg = false;
                    } else {
                        cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                        mIsCallFwdReg = true;
                    }
                } else if (isDeactivate()) {
                    cfAction = CommandsInterface.CF_ACTION_DISABLE;
                } else if (isRegister()) {
                    cfAction = CommandsInterface.CF_ACTION_REGISTRATION;
                } else if (isErasure()) {
                    cfAction = CommandsInterface.CF_ACTION_ERASURE;
                } else {
                    throw new RuntimeException("invalid action");
                }
                int isEnableDesired = ((cfAction == CommandsInterface.CF_ACTION_ENABLE) || (cfAction == CommandsInterface.CF_ACTION_REGISTRATION)) ? 1 : 0;
                Rlog.d(LOG_TAG, "processCode: is CF setCallForward");
                mPhone.mCi.setCallForward(cfAction, reason, serviceClass, dialingNumber, time, obtainMessage(EVENT_SET_CFF_COMPLETE, isVoiceUnconditionalForwarding(reason, serviceClass) ? 1 : 0, isEnableDesired, this));
            }
        } else if (isServiceCodeCallBarring(mSc)) {
            String password = mSia;
            int serviceClass = siToServiceClass(mSib);
            String facility = scToBarringFacility(mSc);
            if (isInterrogate()) {
                mPhone.mCi.queryFacilityLock(facility, password, serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else if (isActivate() || isDeactivate()) {
                mPhone.mCi.setFacilityLock(facility, isActivate(), password, serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_PWD)) {
            String facility;
            String oldPwd = mSib;
            String newPwd = mSic;
            if (isActivate() || isRegister()) {
                mAction = ACTION_REGISTER;
                if (mSia == null) {
                    facility = CommandsInterface.CB_FACILITY_BA_ALL;
                } else {
                    facility = scToBarringFacility(mSia);
                }
                if (newPwd.equals(mPwd)) {
                    mPhone.mCi.changeBarringPassword(facility, oldPwd, newPwd, obtainMessage(EVENT_SET_COMPLETE, this));
                } else {
                    handlePasswordError(com.android.internal.R.string.passwordIncorrect);
                }
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (mSc != null && mSc.equals(SC_WAIT)) {
            int serviceClass = siToServiceClass(mSia);
            if (isActivate() || isDeactivate()) {
                mPhone.mCi.setCallWaiting(isActivate(), serviceClass, obtainMessage(EVENT_SET_COMPLETE, this));
            } else if (isInterrogate()) {
                mPhone.mCi.queryCallWaiting(serviceClass, obtainMessage(EVENT_QUERY_COMPLETE, this));
            } else {
                throw new RuntimeException("Invalid or Unsupported MMI Code");
            }
        } else if (isPinPukCommand()) {
            String oldPinOrPuk = mSia;
            String newPinOrPuk = mSib;
            int pinLen = newPinOrPuk.length();
            if (isRegister()) {
                if (!newPinOrPuk.equals(mSic)) {
                    handlePasswordError(com.android.internal.R.string.mismatchPin);
                } else if (pinLen < 4 || pinLen > 8) {
                    handlePasswordError(com.android.internal.R.string.invalidPin);
                } else if (mSc.equals(SC_PIN) && mUiccApplication != null && mUiccApplication.getState() == AppState.APPSTATE_PUK) {
                    handlePasswordError(com.android.internal.R.string.needPuk);
                } else if (mUiccApplication != null) {
                    Rlog.d(LOG_TAG, "processCode: process mmi service code using UiccApp sc=" + mSc);
                    if (mSc.equals(SC_PIN)) {
                        mUiccApplication.changeIccLockPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PIN2)) {
                        mUiccApplication.changeIccFdnPassword(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK)) {
                        mUiccApplication.supplyPuk(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else if (mSc.equals(SC_PUK2)) {
                        mUiccApplication.supplyPuk2(oldPinOrPuk, newPinOrPuk, obtainMessage(EVENT_SET_COMPLETE, this));
                    } else {
                        throw new RuntimeException("uicc unsupported service code=" + mSc);
                    }
                } else {
                    throw new RuntimeException("No application mUiccApplicaiton is null");
                }
            } else {
                throw new RuntimeException("Ivalid register/action=" + mAction);
            }
        } else if (mPoundString != null) {
            sendUssd(mPoundString);
        } else {
            Rlog.d(LOG_TAG, "processCode: Invalid or Unsupported MMI Code");
            throw new RuntimeException("Invalid or Unsupported MMI Code");
        }
    } catch (RuntimeException exc) {
        mState = State.FAILED;
        mMessage = mContext.getText(com.android.internal.R.string.mmiError);
        Rlog.d(LOG_TAG, "processCode: RuntimeException=" + exc);
        mPhone.onMMIDone(this);
    }
}